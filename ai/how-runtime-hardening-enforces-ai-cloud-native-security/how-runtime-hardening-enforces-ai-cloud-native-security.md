
<!--
title: 运行时强化：AI和云原生安全的守护者
cover: https://cdn.thenewstack.io/media/2025/07/6d6e69ae-programming1.jpg
summary: 运行时安全至关重要，传统边界已失效。强化运行时通过执行隔离、最小化攻击面和实时遏制来保护工作负载，尤其是在AI和GPU环境中。这通过设计实现安全，减少了对警报的依赖。
-->

运行时安全至关重要，传统边界已失效。强化运行时通过执行隔离、最小化攻击面和实时遏制来保护工作负载，尤其是在AI和GPU环境中。这通过设计实现安全，减少了对警报的依赖。

> 译自：[How Runtime Hardening Enforces AI, Cloud Native Security](https://thenewstack.io/how-runtime-hardening-enforces-ai-cloud-native-security/)
> 
> 作者：Alex Zenla

在计算领域，运行时是指代码被主动执行的环境。它包括应用程序和硬件之间的所有内容：操作系统、语言运行时、内核接口和执行上下文。历史上，这个环境是被严格控制的，通常在专用服务器上运行单个工作负载。安全性由操作系统、防火墙和网络分段来强制执行。

如今，这种模式已经崩溃。现代应用程序构建为分布式[微服务](https://thenewstack.io/microservices/)，部署在动态基础设施上，并且通常由自主[AI 代理](https://thenewstack.io/ai-agents-a-comprehensive-introduction-for-developers/)提供支持。[运行时](https://thenewstack.io/cloud-native/the-cloud-native-landscape-the-runtime-layer-explained/)不再是一个清晰定义的系统。它是一个庞大的、短暂的执行层，由多个租户、[容器](https://thenewstack.io/introduction-to-containers/)和工作负载共享。

基于检测的安全已成为一个全行业的跑步机：无休止的调整、追逐误报以及在被攻破后对规则进行改造。尽管进行了大规模投资，但漏洞仍然存在。现在是时候建立一个新的基础了：将安全性嵌入到运行时本身，在那里可以约束执行，而不仅仅是观察。

## **为什么追逐警报会失败**

传统的运行时工具依赖于日志、指标和基于规则的检测来监控工作负载行为，监视异常的系统调用或与预期模式的偏差。但是，这些警报通常不精确、延迟或不相关。

结果是一个无休止的分类循环，与漏洞管理的低效率非常相似。安全运营中心 (SOC) 的分析师和开发人员浪费了宝贵的时间来追逐误报，而有意义的威胁仍然未被检查。

更关键的是，运行时漏洞与应用程序错误不同。应用程序缺陷可能会暴露数据或破坏功能，但运行时弱点可能会提供对主机和系统上每个其他工作负载的无限制访问。

这代表了隔离的根本性崩溃，并使攻击者能够完全控制。如果没有运行时强化，防御者将被迫响应症状，而不是消除被攻破的根本原因。

这种被动模式源于一个过时的假设：可以提前描述威胁。在实践中，攻击者通过链接微妙的行为、滥用有效凭据或通过恶意提示探测 AI 代理来绕过检测。规则维护成为一项全职工作。

还有规则测试的问题。通常假定规则可以检测攻击者行为，但很少（如果有的话）经过测试和验证。由于运行时环境没有隔离或强化，而是专为受信任租户之间的共享计算而设计，因此横向移动或权限提升等整个类别的攻击仍然会成功。

[强化运行时](https://edera.dev/stories/hardened-runtime-standard-for-ai-and-app-security)用适当的隔离边界取代了追逐警报。它通过禁止启用它们的条件来防止这些类别的攻击。如果工作负载被隔离并被拒绝默认访问，则攻击无法传播或升级。

## **传统隔离的崩溃**

历史上，操作系统使用进程模型、用户权限和内存保护来强制执行运行时边界。但是，随着应用程序从单体发展到客户端-服务器，然后到云原生微服务，这些边界消失了。容器共享内核。命名空间提供资源分区，而不是安全性。网络策略控制流量，但不控制行为。

在 Kubernetes 和云环境中，工作负载会不断启动和销毁。团队部署以多种语言编写的服务，每种语言都有不同的库和依赖项。不再有统一的基于操作系统的安全模型可以依赖。现在必须在执行环境本身的较低级别强制执行运行时隔离。

“假设被攻破”现在是唯一可行的安全立场。面向公众的应用程序漏洞利用仍然是主要的初始访问向量，占所有事件的近一半。一旦攻击者站稳脚跟，运行时漏洞就会提供直接途径来提升权限、滥用基础设施和危及相邻的工作负载。

传统的边界工具和构建时检查无法遏制这种威胁。边界必须移动到运行时，在那里，强化的隔离和设计安全性成为最后一道防线。当运行时环境被构建为默认拒绝不必要的访问时，检测变得不那么重要，因为永远不会出现漏洞利用条件。

## **强化运行时实际上意味着什么**

强化运行时强制执行三个基本控制：

1. **真正的执行隔离**
   每个工作负载都在沙盒区域中运行，没有对网络、API 或对等容器的隐式访问。这种隔离不仅仅是通过 Linux 命名空间来强制执行，而是通过深度约束进程环境来强制执行。默认情况下，共享内存、打开设备访问和无范围的网络调用会被阻止。
2. **攻击面最小化** 运行时默认减少代码可以执行的操作。它阻止共享内核为无范围的系统调用提供服务，确保它们不会中断或逃脱受限的运行时环境。它删除不必要的权限并消除主机级别的可见性。它只提供工作负载运行所需的资源。这使得权限提升和资源滥用在结构上不可能。
3. **实时遏制** 当运行时可观测性工具或内核级监视器检测到异常时，运行时会立即响应。它可以切断网络访问、暂停执行或将工作负载置于隔离区。与仅报告问题的传统工具不同，强化运行时会实时采取行动。

这些行为符合 Center for Internet Security (CIS) 和 Security Technical Implementation Guide (STIG) 强化基准。更重要的是，它们由运行时本身持续强制执行，而无需依赖静态策略或动态规则评估。工作负载通过设计而不是通过分层策略逻辑进行隔离和约束。

## **为什么 AI 和 GPU 增加了紧迫性**

AI 工作负载引入了新的执行模式和新的风险。代理不仅仅分析数据。它们自主行动、生成动态代码并根据实时输入执行任意操作。它们持有凭据、触发工作流并与内部系统交互。一旦被攻破，它们就会成为受信任的攻击者。

风险在硬件层增加。GPU 通常在容器和用户之间共享。它们的驱动程序和内存接口暴露给同驻进程。旁道泄漏、内存窥探和未经授权的执行路径不仅仅是理论上的，它们已经被利用。例如，Wiz [最近披露](https://edera.dev/stories/how-edera-eliminates-cve-2025-23266-container-escapes)了 NVIDIA GPU 漏洞，这些漏洞暴露了共享硬件环境中的关键弱点。

强化运行时通过严格限制每个工作负载来包含这些风险。AI 代理和 GPU 驱动的作业在它们可以看到和接触到的内容方面受到限制。内存区域、设备接口和进程间通信都经过明确授权。未经验证，任何事物都不会被认为是安全的。

## **强化运行时是新的边界**

遗留边界已不复存在。运行时现在是必须评估和强制执行信任的点。可观测性和日志记录有助于构建有限的上下文，但如果没有控制，它们是被动的。强化运行时将可见性和操作都带入执行层。

安全和平台团队已经在努力管理检测管道、警报分类和策略蔓延。强化运行时通过消除整个类别的攻击的可能性来减轻这种负担。它使遏制成为默认行为，而不是事后才想到的。