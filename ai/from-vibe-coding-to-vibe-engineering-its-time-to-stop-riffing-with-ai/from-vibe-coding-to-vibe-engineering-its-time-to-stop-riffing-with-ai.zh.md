“随心编码”的时代已经到来，并且已经在生产环境中造成破坏。最初对人工智能辅助开发进行的有趣实验已经悄然渗透到关键工作流程中。在黑客马拉松中，[随心所欲地完成功能开发](https://thenewstack.io/power-apps-plans-feature-vibe-ifies-business-app-dev/)是可以的。但是，一旦你将其推送到生产环境，通过原型设计完成一个迭代可能会导致回归、脆弱的逻辑和安全漏洞。

人们很容易被速度所诱惑：放入提示，获取可运行的代码，然后发布。但是，当正确性、可维护性和可扩展性受到威胁时，这种方法就会崩溃。团队[被迫清理代码](https://thenewstack.io/a-developers-lifecycle-how-i-shifted-my-thinking-and-coding-left/)，这些代码看起来不错，但在压力下却失败了。感觉像是动力，但很快就变成了昂贵的技术债务。

我们需要划清界限：编写可以运行的代码与设计持久的软件不同。任何人都可以获得提示以输出可以编译的代码。构建持久的东西需要架构、测试和意图，而不仅仅是随心所欲。

## 随心编码感觉很好——直到它不再好

随心编码在任何项目的早期阶段都很盛行。没有要集成的现有代码，没有要破坏的测试套件，没有要担心的极端情况。只有你，一些提示以及看起来足够好的演示输出。

它可以工作——直到它不能。

开发人员启动一项新功能。它可以编译。它在happy path上有效。所以它发布了。但是，一周后，收到一份错误报告：用户正在访问仅限管理员的功能。生成的逻辑未能包含授权检查。没有编写任何测试来捕获它。没有人仔细审查代码，因为它看起来没问题。

随着团队的调查，更多的裂缝出现。命名不一致。业务逻辑与 UI 粘合代码混杂在一起。可重用组件是从头开始重写的。一个补丁会破坏另一个补丁。对功能的信心下降，对 AI 工作流程的信任受到侵蚀。

这并非罕见——这是在没有结构的情况下优先考虑速度的可预测结果。

## 左移到随心工程

解决方案不是拒绝人工智能。而是要改进我们使用它的方式。

随心工程保留了人工智能的生成能力，但将其嵌入到结构、意图和约束中。开发人员承担起新的角色：他们定义行为、指定约束并协调专门的代理——不仅是为了生成代码，而且是为了设计软件。

开发人员不是提示[“编写计费函数”，而是指导](https://thenewstack.io/a-software-developers-guide-to-technical-writing/) AI：“扩展现有的 processInvoice() 逻辑以支持基于使用量的层级。使用 utils 中的 formatCurrency()。应用与 subscriptions.ts 中使用的相同的访问检查。”

现在，人工智能不再是自由职业者。它在边界内运行，具有上下文和责任。

随心[工程意味着代理](https://thenewstack.io/ai-alignment-in-practice-what-it-means-and-how-to-get-it/)可以解析你的存储库、了解你的架构并智能地重用组件。代码不仅可以工作，而且可以适配。测试从一开始就包含在内。假定安全的默认值。模式受到尊重。

结果是什么？你可以放入 PR、进行推理和扩展的代码。可以干净地演变的软件。以及一个[可以扩展而不会中断的开发过程](https://thenewstack.io/infrastructure-as-code-increase-security-scale-development/)。

这是随心工程的核心：从即兴创作到协调。你不是编写每一行代码——你是在设计编写、检查和面向未来的系统。

## 开发人员不断变化的角色：从作者到协调者

为了在这个新的协调角色中取得成功，你应该采用以下四个关键实践：

1. **超越任务思考——思考系统**不要仅仅解决一个问题单。询问系统的哪个部分需要演变才能干净且持久地支持此更改。你应该创建一个新的抽象、升级一个共享实用程序还是重构一个核心服务？系统地思考——不仅仅是局部地思考。
2. **编纂你希望 AI 遵循的规则**在生成代码之前，定义你的 AI 助手必须遵循的架构标准、样式约定和工作流程期望。这些可能包括命名规则、首选目录结构、抽象边界或存储库的受保护区域。某些工具会自动推断这些规则，而另一些工具则依赖于明确的指导。但是，在任何情况下，你都应该明确这些期望，以便 AI 像团队成员一样编写代码。
   * 记录你的代码库遵循的规则，并将它们转换为 AI 可以使用的约束，无论是作为规则还是作为你在每个任务中不断引用的文档。
3. **指导 AI 进行重用——以及主动改进**引导 AI 指向代码库的当前和干净的部分，排除旧代码或已弃用的代码。明确引用旨在扩展的可重用组件、实用程序函数和服务。目标是从最强大的基础上发展代码库，并保持 DRY 原则。虽然某些平台可以自动检测到这些重用机会，但其他平台则需要开发人员策划的上下文。无论哪种方式，你的方向都会决定代理是加强还是削弱系统。

并且不要止步于重用——鼓励代理评估和改进它所接触的东西。如果它识别出重用组件中的重复、紧密耦合或过时的逻辑，则应相应地标记和升级它们。由于生成式 AI 可以快速实现，因此你可以负担得起将小型基础设施升级纳入日常任务中。这种思维方式将 AI 从仅仅是任务执行者转变为持续的系统改进者。

* 确定代码库的哪些部分是共享逻辑的“真相来源”——并在提示中主动引用它们，而不仅仅是让 AI 来猜测。
* 当重用代码时，要求 AI 提出改进建议：“如果此实用程序看起来已过时或存在差距，请对其进行重构以与 X 保持一致。”

4. **采用能够揭示未说出口的内容以实现真正对齐的实践**倾向于测试驱动开发 (TDD)。既然 AI 可以以最小的摩擦生成测试，你应该将测试优先工作流程设置为默认设置。这不仅仅是在事后捕获错误——而是为了在实施开始之前识别不一致。通过要求 AI 首先根据你的意图编写测试，你可以在流程的早期发现任何假设、矛盾或模糊的逻辑。
   TDD 强制清晰。它将不确定性转化为可执行的期望——并确保每个实现都基于共同的理解。结果是软件不仅可以工作，而且随着时间的推移保持可维护和测试覆盖。

1. * 在编写任何实现代码之前，提示 AI 生成描述该功能预期行为的测试。
   * 仔细检查生成的测试——它们反映了 AI 如何解释你的意图。根据需要进行澄清或重新调整，以在编码开始之前解决任何不匹配问题。
   * 使其成为你的默认习惯：*先测试，然后构建*。从一开始就使人类和机器保持一致。

5. **与不断演进的代码库保持同步**使用 AI 工具来总结 PR 并跟踪代码演进。主动阅读这些摘要。虽然代理可以完美地了解每个更改的最新情况，但人类却不能。你需要投入精力来保持架构意识，尤其是在 AI 加速开发的情况下。了解系统中正在发生的变化对于做出明智的决策和避免偏差至关重要。

1. * 订阅合并的 PR 摘要并抽出少量时间每天浏览它们，这是值得的。

这些技术定义了现代软件协调者：一个以系统方式思考、定义意图、将 AI 用作协作者（而不仅仅是代码生产者）并以面向未来的方式构建的人。

**少一些即兴创作，多一些协调。这是一个我们实际上可以维护的未来。**