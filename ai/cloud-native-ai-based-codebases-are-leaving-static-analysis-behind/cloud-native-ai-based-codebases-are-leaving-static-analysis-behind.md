<!--
title: 云原生AI代码库：静态分析已成明日黄花
cover: https://cdn.thenewstack.io/media/2025/06/05659af6-amine-mouzaoui-ty6zywq2goo-unsplash-scaled.jpg
summary: 云原生应用和人工智能加速代码开发，传统静态分析工具已无法满足需求。运行时安全工具通过机器学习增强，能实时检测异常行为，适应变化环境，减少误报，应对动态威胁。静态分析仍有作用，但需与运行时监控结合，构建动态、智能的安全体系。
-->

云原生应用和人工智能加速代码开发，传统静态分析工具已无法满足需求。运行时安全工具通过机器学习增强，能实时检测异常行为，适应变化环境，减少误报，应对动态威胁。静态分析仍有作用，但需与运行时监控结合，构建动态、智能的安全体系。

> 译自：[Cloud-Native, AI-Based Codebases Are Leaving Static Analysis Behind](https://thenewstack.io/cloud-native-ai-based-codebases-are-leaving-static-analysis-behind/)
> 
> 作者：Chris Lentricchia

现代软件开发发展迅速，而基于静态分析的安全工具却没有跟上。如今的工程团队正在使用微服务、容器、无服务器函数以及每分钟都在变化的动态基础设施来构建云原生应用程序。同时，生成式人工智能正在加速我们编写代码的方式和时间。开发人员现在使用大型语言模型（LLM）来搭建 API、生成配置文件，甚至处理业务逻辑。结果是什么呢？代码的交付速度比以往任何时候都快，但复杂性和风险也在不断累积。

然而，大多数静态分析工具仍然停留在过去。它们的设计初衷是为单体应用、单语言栈和线性构建流程进行快照，并且代码是手动编写的。在 2025 年，软件已经不再是这样运作的了。

为了跟上步伐，安全工具必须与软件开发同步发展。它们需要在运行时运行，利用机器学习来检测异常行为，并适应不断变化的环境。单靠静态分析根本无法看到足够的东西，也无法足够快地行动。

## **微服务打破了传统的扫描器**

在云原生环境中，你的“代码库”不是一个仓库，而是很多个。你可能用 Go、Python、Node 编写了服务，甚至可能用 Rust 编写了一些性能关键路径。它们通过 Kubernetes 部署，通过 gRPC 或消息队列进行通信，并通过 GitOps 工作流程进行管理。静态工具通常一次分析一个代码库。它们不了解分布式系统。如果漏洞存在于两个服务的交汇处——例如，API 和工作程序之间的不安全身份验证流程——扫描器可能无法发现它。它们无法跨仓库、语言或服务网格跟踪调用。这是一个主要的盲点。

运行时安全工具，通过机器学习增强，可以做到这一点。通过[观察服务之间的实时交互](https://thenewstack.io/trend-report-merging-observability-and-it-service-management/)，它们可以实时检测可疑行为、错误配置或权限提升，即使这些漏洞在代码中不可见。机器学习可以学习正常的点对点服务交互，并标记传统工具遗漏的异常。

## **人工智能编写代码的速度比我们审计代码的速度还快**

让我们坦诚地说：人工智能辅助编码已经成为现实。[根据 Y Combinator 的说法](https://leaddev.com/hiring/95-ai-written-code-unpacking-the-y-combinator-ceos-developer-jobs-bombshell#:~:text=The%20CEO%20of%20famed%20Silicon,%2C)，其四分之一的初创公司报告称，它们使用人工智能生成了 95% 或更多的代码。无论是 GitHub Copilot 还是自定义的大型语言模型工作流程，[开发人员都在使用生成式工具来更快地行动](https://thenewstack.io/ebooks/generative-ai/how-generative-ai-transforms-software-development/)。这意味着更多的代码、更多的依赖项和更大的攻击面——其中大部分代码都没有经过彻底审查。即使大型语言模型的输出表面上“看起来不错”，它也可能缺少重要的上下文：安全默认设置、速率限制、正确的错误处理或合规性约束。事实上，人工智能驱动的[编码可能会引入新的合规性](https://thenewstack.io/checks-by-google-ai-powered-compliance-for-apps-and-code/)问题或漏洞，例如过度允许访问 API 或存储。

传统的基于扫描的[安全工具可能会在部署后数小时甚至数天后才发现同样过度允许的人工智能驱动的代码](https://thenewstack.io/level-up-your-software-quality-with-static-code-analysis/)，使你的组织面临风险，而这正是无法接受的风险。

这就是运行时安全变得至关重要的地方。它通过观察组件在部署后的行为来验证其在实际环境中的行为。机器学习使这些系统能够检测异常访问模式、滥用的权限以及人工智能生成的其他风险迹象。

## **噪音仍然淹没了信号**

如果你使用过静态扫描器，你就会看到这种情况：页面上的警报，其中大多数并不重要。一个*可能*是密钥的字符串（但不是）；一个未使用的变量被标记为潜在的错误；一个硬编码值后面的理论上的注入向量。云原生团队没有时间筛选所有这些噪音，尤其是在每天部署 10 次以上时。误报会削弱信任。人工智能驱动的开发会加剧这种情况，因为它提高了速度。如果你的工具经常发出错误的警报，工程师就会停止倾听。到那时，该工具不仅没有帮助安全，反而损害了安全。

基于运行时的工具改变了游戏规则。它们不依赖于静态猜测，而是根据生产环境中发生的事情发出警报。某个服务是否正在访问它以前从未访问过的数据库？某个 Lambda 函数是否发出了意外的出站请求？借助机器学习，安全工具可以不断改进——学习什么是正常的，减少误报，并在实际问题升级之前标记它们。

## **攻击者知道静态工具是如何工作的——以及如何规避它们**

现代攻击者不会将简单的漏洞利用写入代码。他们使用动态有效载荷、混淆和运行时逻辑，这些是静态工具无法看到的。如果你的扫描器只查看静态代码，它将错过通过运行时环境变量注入或即时组装的恶意软件。这并非纸上谈兵——它今天正在发生，尤其是在供应链攻击中。静态[分析必须与](https://thenewstack.io/dont-mess-with-the-master-working-with-branches-in-git-and-github/)运行时监控和行为工具结合使用。否则，它只是在检查打开的窗户上的锁。

静态工具永远不会看到运行时有效载荷。但是运行时安全工具会，尤其是那些由机器学习驱动的工具。通过分析实时执行模式，机器学习模型可以检测可疑行为：横向移动、凭据滥用或数据泄露。运行时保护不仅可以发现问题，还可以阻止正在进行的主动威胁。

在一个供应链攻击日益普遍的世界中，这种实时防御不再是可选的。它至关重要。

## **CI/CD 无法等待**

云原生团队生活在 CI/CD 管道中。代码会被自动构建、测试和部署，有时每小时几次。无法跟上的安全工具将被忽略或删除。扫描时间过长？过多的虚假警报？缺乏对容器或 IaC 的支持？这是一个决定性因素。为了在 DevSecOps 工作流程中发挥作用，静态工具需要快速、准确，并且专为自动化而构建。它们需要扫描容器、Kubernetes 清单、Terraform 文件和 Helm chart，而不仅仅是应用程序代码。而且它们需要做到这一点而不阻塞团队。

运行时工具旨在在部署后运行，与你的应用程序一起持续运行。它们不需要阻塞构建——它们保护的是正在运行的东西。更好的是，当与机器学习相结合时，运行时工具每次部署都会变得更智能。它们可以识别跨版本的正常行为，减少噪音，并随着你的堆栈发展而适应。这就是为速度而构建的安全。

## **静态分析并没有消亡，但它还不够**

安全不能是事后诸葛亮——它必须与你的堆栈融为一体。如果你的工具不是为云原生和人工智能原生代码构建的，那么它就已经过时了。静态分析仍然有其作用，尤其是在敏感工作负载中。但就其本身而言，它对于现代[云原生开发](https://thenewstack.io/cloud-native/ "cloud native development")来说还远远不够：它无法跨服务查看，它难以应对高速人工智能生成的代码，它让团队淹没在噪音中，并且它会减慢管道的速度。

我们需要构建用于运行时的安全工具，而不是仅仅依赖于静态分析，这些工具可以监视实时环境并使用机器学习进行调整，同时仍然提供静态扫描的优势。这种向动态、智能运行时监控的转变将有助于管理复杂性，减少不相关的警报，并降低安全风险，同时不会阻碍 DevSecOps 工作流程，从而将保护扩展到整个软件开发生命周期。