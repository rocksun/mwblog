
<!DOCTYPE html><html lang="en" data-theme="light" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="image" property="og:image" content="https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1754066340300%2F28af3dcf-9f58-4299-b182-9be5216337bc.jpeg%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng"/><link rel="canonical" href="https://blog.hayride.dev/composable-agents"/><title>Composable Agents</title><meta name="description" content="Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly"/><meta property="og:title" content="Composable Agents"/><meta property="og:description" content="Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly"/><meta property="og:site_name" content="Hayride"/><meta property="og:type" content="article"/><meta property="og:url" content="https://blog.hayride.dev/composable-agents"/><meta name="author" content="Ethan Lewis"/><meta property="article:author" content="https://hashnode.com/@elewis"/><link rel="author" href="https://hashnode.com/@elewis"/><link rel="icon" type="image/png" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png?auto=compress,format&amp;format=webp&amp;fm=png"/><meta name="theme-color" content="#f6f7fb"/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:title" content="Composable Agents"/><meta property="twitter:description" content="Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly"/><meta property="twitter:image" content="https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1754066340300%2F28af3dcf-9f58-4299-b182-9be5216337bc.jpeg%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng"/><meta property="twitter:creator" content="@elewis787"/><style>/* Monkai theme */
          .hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}
            /* Monkai theme ends */</style><link rel="alternate" type="application/rss+xml" title="RSS Feed for Composable Agents" href="https://blog.hayride.dev/composable-agents/rss.xml"/><link rel="preload" as="image" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png?w=1000&amp;h=250&amp;auto=compress,format&amp;format=webp"/><link rel="preload" as="image" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp"/><meta name="next-head-count" content="25"/><style>#nprogress{pointer-events:none}#nprogress .bar{background:#29d;position:fixed;z-index:1031;top:0;left:0;width:100%;height:2px}#nprogress .peg{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg) translate(0,-4px);-ms-transform:rotate(3deg) translate(0,-4px);transform:rotate(3deg) translate(0,-4px)}#nprogress .spinner{display:block;position:fixed;z-index:1031;top:15px;right:15px}#nprogress .spinner-icon{width:18px;height:18px;box-sizing:border-box;border:solid 2px transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:nprogress-spinner .4s linear infinite;animation:nprogress-spinner .4s linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .bar,.nprogress-custom-parent #nprogress .spinner{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style><script async="" src="https://ping.hashnode.com/gtag/js?id=G-72XG3F8LNJ"></script><script type="text/javascript">
    window.dataLayer = window.dataLayer || [];
    function gtag(){window.dataLayer.push(arguments);}
    gtag('js', new Date());
  </script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/869e64419a32f5ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/869e64419a32f5ba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script defer="" src="/_next/static/chunks/8820-56721d947d773244.js"></script><script defer="" src="/_next/static/chunks/3364-87c2ffca7936c855.js"></script><script defer="" src="/_next/static/chunks/8226.64bcf70d809f2c9f.js"></script><script defer="" src="/_next/static/chunks/5950-ac4ab424aa3bdc31.js"></script><script defer="" src="/_next/static/chunks/7179.58a3a6a905ed3c5b.js"></script><script src="/_next/static/chunks/webpack-57c27ace014ad21e.js" defer=""></script><script src="/_next/static/chunks/framework-ce84985cd166733a.js" defer=""></script><script src="/_next/static/chunks/main-7636331dc094a8a9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8a232011d05831de.js" defer=""></script><script src="/_next/static/chunks/0b5ea8d6-208c5eca82a94965.js" defer=""></script><script src="/_next/static/chunks/6365-3d0e1852af604b43.js" defer=""></script><script src="/_next/static/chunks/6933-f312215db97b5535.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-0670863b9e4a6e11.js" defer=""></script><script src="/_next/static/YNdX74WR8L1Q36DPndWD2/_buildManifest.js" defer=""></script><script src="/_next/static/YNdX74WR8L1Q36DPndWD2/_ssgManifest.js" defer=""></script><style id="__jsx-908433161">@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Book-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Book-WebXL.woff")format("woff");font-weight:450;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Medium-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Medium-WebXL.woff")format("woff");font-weight:500;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-SemiBold-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-SemiBold-WebXL.woff")format("woff");font-weight:600;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Bold-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Bold-WebXL.woff")format("woff");font-weight:700;font-style:normal;font-display:block}html{--font-inter:__Inter_52d07b;--font-suisse-intl:'Suisse Intl';--font-mermaid:var(--font-inter)}</style></head><body class="bg-white leading-normal antialiased dark:bg-slate-950"><input type="hidden" id="hn-user"/><style id="__jsx-908433161">@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Book-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Book-WebXL.woff")format("woff");font-weight:450;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Medium-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Medium-WebXL.woff")format("woff");font-weight:500;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-SemiBold-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-SemiBold-WebXL.woff")format("woff");font-weight:600;font-style:normal;font-display:block}@font-face{font-family:"Suisse Intl";src:url("/fonts/SuisseIntl-Bold-WebXL.woff2")format("woff2"),url("/fonts/SuisseIntl-Bold-WebXL.woff")format("woff");font-weight:700;font-style:normal;font-display:block}html{--font-inter:__Inter_52d07b;--font-suisse-intl:'Suisse Intl';--font-mermaid:var(--font-inter)}</style><div id="__next"><div class="bg-white dark:bg-slate-950" data-theme="light"><script type="application/ld+json">{"@context":"https://schema.org","@type":"NewsArticle","url":"https://blog.hayride.dev/composable-agents","mainEntityOfPage":"https://blog.hayride.dev/composable-agents","headline":"Composable Agents","description":"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly","datePublished":"2025-08-01T16:39:28.061Z","dateModified":"2025-08-01T19:21:45.491Z","isAccessibleForFree":true,"author":{"@type":"Person","name":"Ethan Lewis","url":"https://hashnode.com/@elewis","sameAs":"https://twitter.com/elewis787"},"publisher":{"@type":"Organization","name":"Hayride","url":"https://blog.hayride.dev","logo":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png"},"image":{"@type":"ImageObject","url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg"}}</script><header class="blog-header z-50 w-full border-b relative transform-none md:sticky md:top-0 md:left-0 md:backdrop-blur-lg border-black/10 bg-white bg-opacity-70 dark:border-white/10 dark:bg-slate-900 dark:bg-opacity-70"><div class="container mx-auto px-2 md:px-4 md:py-1 2xl:px-10"><div class="relative z-40 flex flex-row items-center justify-between pb-2 pt-8 md:py-4"><div class="mb-2 flex flex-row items-center md:mb-0 dark:text-white"><a aria-label="Back to blog home" class="blog-back-to-home-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20 mr-2 p-3" data-state="closed" href="/"><svg class="h-4 w-4 fill-current pr-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 17"><path d="M7.75135 16.7197L0.885098 9.55347C0.683348 9.31347 0.600098 9.08847 0.600098 8.89722C0.600098 8.70597 0.68331 8.44834 0.850898 8.27509L7.71715 1.10884C8.06035 0.749066 8.6299 0.737366 8.9884 1.08189C9.34933 1.42408 9.36107 1.99576 9.01535 2.35351L2.7466 8.89722L9.0466 15.4747C9.39231 15.831 9.38057 16.404 9.01965 16.7463C8.6626 17.091 8.0926 17.0797 7.75135 16.7197Z"></path></svg></a><div class="mr-2"><button type="button" aria-label="Open blog links" class="blog-bars-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20.9889 11.9969H11.9945H3M20.9889 17.8745H3M21 6.12451H3" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div><div class="hidden md:block"><div class="blog-main-logo"><a class="blog-logo focus-ring-base flex flex-row items-center focus-ring-colors-base w-44" aria-label="Hayride home page" href="/?source=top_nav_blog_home"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271000%27%20height=%27250%27/%3e"/></span><img alt="Hayride" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png?w=1000&amp;h=250&amp;auto=compress,format&amp;format=webp" decoding="async" data-nimg="intrinsic" class="block w-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain"/></span></a></div></div></div><div class="flex flex-row items-center dark:text-white"><button type="button" aria-label="Open blog search" class="blog-search-button focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path d="M21 21L15.8091 15.8091M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button type="button" aria-label="Toggle blog theme" class="blog-theme-switcher focus-ring-base flex flex-row items-center rounded-full font-medium transition duration-100 ease-in-out focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20 mr-2 p-2" data-state="closed"><svg class="h-6 w-6 stroke-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path d="M3 11.4489C3 16.7238 7.16904 21 12.3118 21C16.2709 21 19.6529 18.4657 21 14.8925C19.9331 15.4065 18.7418 15.6938 17.485 15.6938C12.9137 15.6938 9.20787 11.8928 9.20787 7.20396C9.20787 5.24299 9.85605 3.4373 10.9446 2C6.45002 2.6783 3 6.65034 3 11.4489Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><div class="hidden md:mr-2 md:block"><div class="flex animate-pulse flex-row items-center rounded-full border-1-1/2 px-4 py-2 text-center text-sm font-medium bg-slate-100 dark:border-slate-900 dark:bg-slate-800"><svg class="invisible mr-2 h-5 w-5" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.2953 4.58698C13.9301 4.37611 13.683 4.00814 13.626 3.59028L13.4336 2.17939C13.3415 1.50373 12.7644 1 12.0825 1L9.91765 1C9.23573 1 8.65865 1.50373 8.56652 2.17939L8.37412 3.5903C8.31709 4.00849 8.06963 4.37672 7.70395 4.58749L7.0923 4.94003C6.72723 5.15046 6.28538 5.18029 5.89533 5.02084L4.57791 4.48227C3.9467 4.22423 3.22192 4.47214 2.88096 5.06269L1.79854 6.9375C1.45758 7.52805 1.60528 8.27969 2.14436 8.69731L3.26948 9.56895C3.60259 9.82701 3.79768 10.2246 3.79799 10.646L3.7985 11.3519C3.7988 11.774 3.60364 12.1724 3.26999 12.4309L2.14433 13.3029C1.60525 13.7205 1.45755 14.4722 1.79851 15.0627L2.88093 16.9375C3.22189 17.5281 3.94667 17.776 4.57788 17.518L5.89588 16.9792C6.28624 16.8196 6.72847 16.8496 7.0937 17.0604L7.70483 17.4133C8.07006 17.6241 8.31718 17.9921 8.37416 18.41L8.56652 19.8206C8.65865 20.4963 9.23573 21 9.91765 21L12.0825 21C12.7644 21 13.3415 20.4963 13.4336 19.8206L13.626 18.4098C13.683 17.9916 13.9305 17.6234 14.2962 17.4127L14.9077 17.0602C15.2728 16.8497 15.7146 16.8199 16.1047 16.9794L17.4221 17.5179C18.0533 17.776 18.7781 17.5281 19.119 16.9375L20.2015 15.0627C20.5424 14.4721 20.3947 13.7205 19.8557 13.3029L18.7305 12.4312C18.3974 12.1732 18.2023 11.7756 18.202 11.3542L18.2015 10.6483C18.2012 10.2263 18.3964 9.82784 18.73 9.56935L19.8556 8.69734C20.3947 8.27972 20.5424 7.52809 20.2014 6.93753L19.119 5.06272C18.7781 4.47217 18.0533 4.22427 17.4221 4.48231L16.1042 5.02106C15.7138 5.18064 15.2716 5.15063 14.9064 4.93976L14.2953 4.58698Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M13.3619 12.3637C12.6088 13.6681 10.9408 14.1151 9.63638 13.362C8.33195 12.6088 7.88502 10.9409 8.63813 9.63643C9.39125 8.33199 11.0592 7.88506 12.3637 8.63818C13.6681 9.39129 14.115 11.0593 13.3619 12.3637Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="invisible">Follow</span></div></div><div class="hidden md:mr-2 md:block"><div class="animate-pulse rounded-full border-1-1/2 p-2 bg-slate-100 dark:border-slate-900 dark:bg-slate-800"><svg class="invisible h-5 w-5" viewBox="0 0 22 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.1728 3.50973C12.587 3.50973 12.9228 3.17395 12.9228 2.75973C12.9228 2.34552 12.587 2.00973 12.1728 2.00973V3.50973ZM18.958 9.10996C18.958 8.69575 18.6222 8.35996 18.208 8.35996C17.7938 8.35996 17.458 8.69575 17.458 9.10996H18.958ZM1.5018 5.97023C1.1338 5.7801 0.681352 5.9243 0.491222 6.2923C0.301092 6.66029 0.445283 7.11275 0.813283 7.30288L1.5018 5.97023ZM15.6397 8.12794C15.9841 7.8979 16.0769 7.43217 15.8468 7.08771C15.6168 6.74325 15.1511 6.6505 14.8066 6.88055L15.6397 8.12794ZM7.29742 9.80877L6.95316 10.4751L7.29742 9.80877ZM9.154 10.5963L9.2714 9.85557L9.154 10.5963ZM12.1823 9.53509L11.7658 8.91139L12.1823 9.53509ZM10.4253 10.5251L10.2259 9.80209L10.4253 10.5251ZM16.1797 3.11305C15.8868 2.82016 15.4119 2.82016 15.1191 3.11305C14.8262 3.40595 14.8262 3.88082 15.1191 4.17371L16.1797 3.11305ZM17.3215 5.31545L16.7911 5.84578C16.9358 5.99043 17.1332 6.06972 17.3377 6.06527C17.5423 6.06083 17.7361 5.97304 17.8743 5.82224L17.3215 5.31545ZM21.5529 1.80928C21.8328 1.50394 21.8121 1.02952 21.5068 0.749625C21.2015 0.46973 20.727 0.490357 20.4471 0.795697L21.5529 1.80928ZM17.458 14.2317C17.458 14.8735 16.9378 15.3937 16.296 15.3937V16.8937C17.7662 16.8937 18.958 15.7019 18.958 14.2317H17.458ZM16.296 15.3937H2.912V16.8937H16.296V15.3937ZM2.912 15.3937C2.27025 15.3937 1.75 14.8735 1.75 14.2317H0.25C0.25 15.7019 1.44182 16.8937 2.912 16.8937V15.3937ZM1.75 14.2317V4.67173H0.25V14.2317H1.75ZM1.75 4.67173C1.75 4.02998 2.27024 3.50973 2.912 3.50973V2.00973C1.44182 2.00973 0.25 3.20155 0.25 4.67173H1.75ZM2.912 3.50973H12.1728V2.00973H2.912V3.50973ZM18.958 14.2317V9.10996H17.458V14.2317H18.958ZM0.813283 7.30288L6.95316 10.4751L7.64168 9.14245L1.5018 5.97023L0.813283 7.30288ZM12.5988 10.1588L15.6397 8.12794L14.8066 6.88055L11.7658 8.91139L12.5988 10.1588ZM6.95316 10.4751C7.82539 10.9257 8.40949 11.2377 9.03661 11.3371L9.2714 9.85557C8.93995 9.80304 8.60585 9.6406 7.64168 9.14245L6.95316 10.4751ZM11.7658 8.91139C10.8633 9.51412 10.5494 9.71287 10.2259 9.80209L10.6247 11.2481C11.2368 11.0793 11.7824 10.704 12.5988 10.1588L11.7658 8.91139ZM9.03661 11.3371C9.56626 11.421 10.1077 11.3907 10.6247 11.2481L10.2259 9.80209C9.91519 9.88779 9.58974 9.90602 9.2714 9.85557L9.03661 11.3371ZM15.1191 4.17371L16.7911 5.84578L17.8518 4.78512L16.1797 3.11305L15.1191 4.17371ZM17.8743 5.82224L21.5529 1.80928L20.4471 0.795697L16.7686 4.80866L17.8743 5.82224Z"></path></svg></div></div><div class="h-10 w-10 animate-pulse rounded-full border-1-1/2 bg-slate-100 dark:border-slate-900 dark:bg-slate-800"></div></div></div><div class="mx-auto my-5 flex w-2/3 flex-row items-center justify-center md:hidden"><div class="blog-main-logo"><a class="blog-logo focus-ring-base flex flex-row items-center focus-ring-colors-base w-64" aria-label="Hayride home page" href="/?source=top_nav_blog_home"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271000%27%20height=%27250%27/%3e"/></span><img alt="Hayride" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png?w=1000&amp;h=250&amp;auto=compress,format&amp;format=webp" decoding="async" data-nimg="intrinsic" class="block w-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain"/></span></a></div></div><div class="blog-sub-header mb-4 md:hidden" data-testid="blog-sub-header"><div class="md:(mb-0 ml-auto) flex flex-row items-center justify-center gap-x-3"><div class="flex animate-pulse flex-row items-center rounded-full border-1-1/2 px-4 py-2 text-center text-sm font-medium bg-slate-100 dark:border-slate-900 dark:bg-slate-800"><svg class="invisible mr-2 h-5 w-5" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.2953 4.58698C13.9301 4.37611 13.683 4.00814 13.626 3.59028L13.4336 2.17939C13.3415 1.50373 12.7644 1 12.0825 1L9.91765 1C9.23573 1 8.65865 1.50373 8.56652 2.17939L8.37412 3.5903C8.31709 4.00849 8.06963 4.37672 7.70395 4.58749L7.0923 4.94003C6.72723 5.15046 6.28538 5.18029 5.89533 5.02084L4.57791 4.48227C3.9467 4.22423 3.22192 4.47214 2.88096 5.06269L1.79854 6.9375C1.45758 7.52805 1.60528 8.27969 2.14436 8.69731L3.26948 9.56895C3.60259 9.82701 3.79768 10.2246 3.79799 10.646L3.7985 11.3519C3.7988 11.774 3.60364 12.1724 3.26999 12.4309L2.14433 13.3029C1.60525 13.7205 1.45755 14.4722 1.79851 15.0627L2.88093 16.9375C3.22189 17.5281 3.94667 17.776 4.57788 17.518L5.89588 16.9792C6.28624 16.8196 6.72847 16.8496 7.0937 17.0604L7.70483 17.4133C8.07006 17.6241 8.31718 17.9921 8.37416 18.41L8.56652 19.8206C8.65865 20.4963 9.23573 21 9.91765 21L12.0825 21C12.7644 21 13.3415 20.4963 13.4336 19.8206L13.626 18.4098C13.683 17.9916 13.9305 17.6234 14.2962 17.4127L14.9077 17.0602C15.2728 16.8497 15.7146 16.8199 16.1047 16.9794L17.4221 17.5179C18.0533 17.776 18.7781 17.5281 19.119 16.9375L20.2015 15.0627C20.5424 14.4721 20.3947 13.7205 19.8557 13.3029L18.7305 12.4312C18.3974 12.1732 18.2023 11.7756 18.202 11.3542L18.2015 10.6483C18.2012 10.2263 18.3964 9.82784 18.73 9.56935L19.8556 8.69734C20.3947 8.27972 20.5424 7.52809 20.2014 6.93753L19.119 5.06272C18.7781 4.47217 18.0533 4.22427 17.4221 4.48231L16.1042 5.02106C15.7138 5.18064 15.2716 5.15063 14.9064 4.93976L14.2953 4.58698Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M13.3619 12.3637C12.6088 13.6681 10.9408 14.1151 9.63638 13.362C8.33195 12.6088 7.88502 10.9409 8.63813 9.63643C9.39125 8.33199 11.0592 7.88506 12.3637 8.63818C13.6681 9.39129 14.115 11.0593 13.3619 12.3637Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="invisible">Follow</span></div><div class="animate-pulse rounded-full border-1-1/2 p-2 bg-slate-100 dark:border-slate-900 dark:bg-slate-800"><svg class="invisible h-5 w-5" viewBox="0 0 22 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.1728 3.50973C12.587 3.50973 12.9228 3.17395 12.9228 2.75973C12.9228 2.34552 12.587 2.00973 12.1728 2.00973V3.50973ZM18.958 9.10996C18.958 8.69575 18.6222 8.35996 18.208 8.35996C17.7938 8.35996 17.458 8.69575 17.458 9.10996H18.958ZM1.5018 5.97023C1.1338 5.7801 0.681352 5.9243 0.491222 6.2923C0.301092 6.66029 0.445283 7.11275 0.813283 7.30288L1.5018 5.97023ZM15.6397 8.12794C15.9841 7.8979 16.0769 7.43217 15.8468 7.08771C15.6168 6.74325 15.1511 6.6505 14.8066 6.88055L15.6397 8.12794ZM7.29742 9.80877L6.95316 10.4751L7.29742 9.80877ZM9.154 10.5963L9.2714 9.85557L9.154 10.5963ZM12.1823 9.53509L11.7658 8.91139L12.1823 9.53509ZM10.4253 10.5251L10.2259 9.80209L10.4253 10.5251ZM16.1797 3.11305C15.8868 2.82016 15.4119 2.82016 15.1191 3.11305C14.8262 3.40595 14.8262 3.88082 15.1191 4.17371L16.1797 3.11305ZM17.3215 5.31545L16.7911 5.84578C16.9358 5.99043 17.1332 6.06972 17.3377 6.06527C17.5423 6.06083 17.7361 5.97304 17.8743 5.82224L17.3215 5.31545ZM21.5529 1.80928C21.8328 1.50394 21.8121 1.02952 21.5068 0.749625C21.2015 0.46973 20.727 0.490357 20.4471 0.795697L21.5529 1.80928ZM17.458 14.2317C17.458 14.8735 16.9378 15.3937 16.296 15.3937V16.8937C17.7662 16.8937 18.958 15.7019 18.958 14.2317H17.458ZM16.296 15.3937H2.912V16.8937H16.296V15.3937ZM2.912 15.3937C2.27025 15.3937 1.75 14.8735 1.75 14.2317H0.25C0.25 15.7019 1.44182 16.8937 2.912 16.8937V15.3937ZM1.75 14.2317V4.67173H0.25V14.2317H1.75ZM1.75 4.67173C1.75 4.02998 2.27024 3.50973 2.912 3.50973V2.00973C1.44182 2.00973 0.25 3.20155 0.25 4.67173H1.75ZM2.912 3.50973H12.1728V2.00973H2.912V3.50973ZM18.958 14.2317V9.10996H17.458V14.2317H18.958ZM0.813283 7.30288L6.95316 10.4751L7.64168 9.14245L1.5018 5.97023L0.813283 7.30288ZM12.5988 10.1588L15.6397 8.12794L14.8066 6.88055L11.7658 8.91139L12.5988 10.1588ZM6.95316 10.4751C7.82539 10.9257 8.40949 11.2377 9.03661 11.3371L9.2714 9.85557C8.93995 9.80304 8.60585 9.6406 7.64168 9.14245L6.95316 10.4751ZM11.7658 8.91139C10.8633 9.51412 10.5494 9.71287 10.2259 9.80209L10.6247 11.2481C11.2368 11.0793 11.7824 10.704 12.5988 10.1588L11.7658 8.91139ZM9.03661 11.3371C9.56626 11.421 10.1077 11.3907 10.6247 11.2481L10.2259 9.80209C9.91519 9.88779 9.58974 9.90602 9.2714 9.85557L9.03661 11.3371ZM15.1191 4.17371L16.7911 5.84578L17.8518 4.78512L16.1797 3.11305L15.1191 4.17371ZM17.8743 5.82224L21.5529 1.80928L20.4471 0.795697L16.7686 4.80866L17.8743 5.82224Z"></path></svg></div></div><div class="mt-6"><div class="blog-social-media-section flex flex-row flex-wrap gap-y-2 justify-center gap-x-1.5 text-slate-700 dark:text-slate-300"><a href="https://github.com/hayride-dev" aria-label="Find me on Github, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://hayride.dev" aria-label="Check out my website, external website, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 24 24"><path d="M17.9 17.39c-.26-.8-1.01-1.39-1.9-1.39h-1v-3a1 1 0 0 0-1-1H8v-2h2a1 1 0 0 0 1-1V7h2a2 2 0 0 0 2-2v-.41c2.93 1.18 5 4.05 5 7.41 0 2.08-.8 3.97-2.1 5.39M11 19.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.22.21-1.79L9 15v1a2 2 0 0 0 2 2m1-16A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10A10 10 0 0 0 12 2z"></path></svg></a><a href="/rss.xml" aria-label="Open blog XML Feed, opens in new tab" target="_blank" rel="me noopener" class="focus-ring-base flex flex-row items-center justify-center rounded-full p-2 transition-colors duration-150 focus-ring-colors-base hover:bg-black/10 dark:hover:bg-white/20"><svg class="h-5 w-5 fill-current" viewBox="0 0 448 512"><path d="M80 368c17.645 0 32 14.355 32 32s-14.355 32-32 32-32-14.355-32-32 14.355-32 32-32m0-48c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.449-237.834-198.057-429.163-435.61-435.61C5.609 31.821 0 37.229 0 44.007v24.02c0 6.482 5.147 11.808 11.626 11.992 211.976 6.04 382.316 176.735 388.354 388.354.185 6.479 5.51 11.626 11.992 11.626h24.02c6.78.001 12.187-5.608 12.004-12.384zm-136.239-.05C305.401 305.01 174.966 174.599 12.435 168.243 5.643 167.977 0 173.444 0 180.242v24.024c0 6.431 5.072 11.705 11.497 11.98 136.768 5.847 246.411 115.511 252.258 252.258.275 6.425 5.549 11.497 11.98 11.497h24.024c6.797-.001 12.264-5.644 11.998-12.436z"></path></svg></a></div></div></div></div></header><div class="blog-post-area relative z-40"><main class="blog-post-detail-card pb-24"><article><style>
    [data-rmiz-ghost] {
      position: absolute;
      pointer-events: none;
    }
    [data-rmiz-btn-zoom],
    [data-rmiz-btn-unzoom] {
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      border: none;
      box-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
      color: #fff;
      height: 40px;
      margin: 0;
      outline-offset: 2px;
      padding: 9px;
      touch-action: manipulation;
      width: 40px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    [data-rmiz-btn-zoom]:not(:focus):not(:active) {
      position: absolute;
      clip: rect(0 0 0 0);
      clip-path: inset(50%);
      height: 1px;
      overflow: hidden;
      pointer-events: none;
      white-space: nowrap;
      width: 1px;
    }
    [data-rmiz-btn-zoom] {
      position: absolute;
      inset: 10px 10px auto auto;
      cursor: zoom-in;
    }
    [data-rmiz-btn-unzoom] {
      position: absolute;
      inset: 20px 20px auto auto;
      cursor: zoom-out;
      z-index: 1;
      display: none;
    }
    [data-rmiz-content="found"] img,
    [data-rmiz-content="found"] svg,
    [data-rmiz-content="found"] [role="img"],
    [data-rmiz-content="found"] [data-zoom] {
      cursor: zoom-in;
    }
    [data-rmiz-modal]::backdrop {
      display: none;
    }
    [data-rmiz-modal][open] {
      position: fixed;
      width: 100vw;
      width: 100dvw;
      height: 100vh;
      height: 100dvh;
      max-width: none;
      max-height: none;
      margin: 0;
      padding: 0;
      border: 0;
      background: transparent;
      overflow: hidden;
    }
    [data-rmiz-modal-overlay] {
      position: absolute;
      inset: 0;
      transition: background-color 0.3s;
    }
    [data-rmiz-modal-overlay="hidden"] {
      background-color: rgba(255, 255, 255, 0);
    }
    [data-rmiz-modal-overlay="visible"] {
      /* This bg color is different from default */
      background-color: rgba(0, 0, 0, 0.5);
    }
    [data-rmiz-modal-content] {
      position: relative;
      width: 100%;
      height: 100%;
    }
    [data-rmiz-modal-img] {
      position: absolute;
      cursor: zoom-out;
      image-rendering: high-quality;
      transform-origin: top left;
      transition: transform 0.3s;
      /* This is added additionally to override prose styles of image*/
      margin: 0 !important;
    }
    @media (prefers-reduced-motion: reduce) {
      [data-rmiz-modal-overlay],
      [data-rmiz-modal-img] {
        transition-duration: 0.01ms !important;
      }
    }
</style><div class="blog-article-page container relative mx-auto grid grid-cols-8"><div class="col-span-full lg:col-span-6 lg:col-start-2"><div class="relative"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:52.5%"></span><img alt="Composable Agents" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp" decoding="async" data-nimg="responsive" class="mb-0 block w-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;background-size:cover;background-position:0% 0%;filter:blur(20px);background-image:url(&quot;https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg?w=400&amp;h=210&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp&amp;fm=blurhash&quot;)"/><noscript><img alt="Composable Agents" decoding="async" data-nimg="responsive" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="mb-0 block w-full" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp"/></noscript></span></div><div class="mt-6 break-words px-4 text-center font-heading text-3xl font-bold text-slate-900 dark:text-white md:mt-10 md:px-5 md:text-4xl lg:px-8 xl:px-20 xl:text-5xl mb-5"><h1 class="leading-tight" data-query="post-title">Composable Agents</h1></div><div class="mb-8 px-4 text-center font-heading md:mb-14 md:px-5 lg:px-8 xl:px-20"><h2 class="text-2xl leading-snug text-slate-700 dark:text-slate-400 md:text-3xl xl:text-3xl">It’s morphing time!</h2></div><div class="relative z-20 mb-8 flex flex-row flex-wrap items-center justify-center px-4 md:-mt-7 md:mb-14 md:text-lg last:md:mb-10"><div class="mb-5 flex w-full flex-row items-center justify-center md:mb-0 md:w-auto md:justify-start"><div style="z-index:1" class="overflow-hidden rounded-full  bg-slate-200  dark:bg-white/20 md:mr-3 h-10 w-10 md:h-12 md:w-12"><a href="https://hashnode.com/@elewis" class="relative block h-full w-full"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27200%27/%3e"/></span><img alt="Ethan Lewis&#x27;s photo" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="relative z-20 block w-full rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Ethan Lewis&#x27;s photo" loading="lazy" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="relative z-20 block w-full rounded-full" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg?w=200&amp;h=200&amp;fit=crop&amp;crop=faces&amp;auto=compress,format&amp;format=webp"/></noscript></span></a></div><a href="https://hashnode.com/@elewis" class="ml-2 font-semibold text-slate-600 dark:text-white md:ml-0"><span>Ethan Lewis</span></a></div><div class="mb-5 flex w-full flex-row items-center justify-center md:mb-0 md:w-auto md:justify-start"><span class="mx-3 hidden font-bold text-slate-500 md:block">·</span><a href="https://blog.hayride.dev/composable-agents" class="tooltip-handle text-slate-600 dark:text-slate-400" data-title="Aug 1, 2025 16:39"><time dateTime="2025-08-01T16:39:28.061Z">Aug 1, 2025</time></a><span class="mx-3 block font-bold text-slate-500">·</span><p class="flex flex-row items-center text-slate-600 dark:text-slate-400"><svg class="mr-2 h-5 w-5 fill-current opacity-75" viewBox="0 0 576 512"><path d="M540.9 56.77c-45.95-16.66-90.23-24.09-129.1-24.75-60.7.94-102.7 17.45-123.8 27.72-21.1-10.27-64.1-26.8-123.2-27.74-40-.05-84.4 8.35-129.7 24.77C14.18 64.33 0 84.41 0 106.7v302.9c0 14.66 6.875 28.06 18.89 36.8 11.81 8.531 26.64 10.98 40.73 6.781 118.9-36.34 209.3 19.05 214.3 22.19C277.8 477.6 281.2 480 287.1 480c6.52 0 10.12-2.373 14.07-4.578 10.78-6.688 98.3-57.66 214.3-22.27 14.11 4.25 28.86 1.75 40.75-6.812C569.1 437.6 576 424.2 576 409.6V106.7c0-22.28-14.2-42.35-35.1-49.93zM272 438.1c-24.95-12.03-71.01-29.37-130.5-29.37-27.83 0-58.5 3.812-91.19 13.77-4.406 1.344-9 .594-12.69-2.047C34.02 417.8 32 413.1 32 409.6V106.7c0-8.859 5.562-16.83 13.86-19.83C87.66 71.7 127.9 63.95 164.5 64c51.8.81 89.7 15.26 107.5 23.66V438.1zm272-28.5c0 4.375-2.016 8.234-5.594 10.84-3.766 2.703-8.297 3.422-12.69 2.125C424.1 391.6 341.3 420.4 304 438.3V87.66c17.8-8.4 55.7-22.85 107.4-23.66 35.31-.063 76.34 7.484 118.8 22.88 8.2 3 13.8 10.96 13.8 19.82v302.9z"></path></svg><span>11<!-- --> min read</span></p></div></div></div></div><div class="blog-content-wrapper article-main-wrapper container relative z-30 mx-auto grid grid-flow-row grid-cols-8 xl:gap-6 2xl:grid-cols-10"><section class="blog-content-main z-20 col-span-8 mb-10 px-4 md:z-10 lg:col-span-6 lg:col-start-2 lg:px-0 xl:col-span-6 xl:col-start-2 2xl:col-span-6 2xl:col-start-3"><div class="relative"><div class="relative w-full overflow-hidden border border-slate-200 bg-white dark:border-slate-800/80 dark:bg-slate-950 mx-auto mb-10 max-w-[812px] rounded-xl"><div class="pr-4 pb-4 max-h-[400px] overflow-hidden"><h2 class="px-6 py-5 pb-4 text-lg font-semibold text-slate-800 dark:text-slate-100"><span>Table of contents</span></h2><ul class="pl-4 dark:border-slate-800"><li><a href="#heading-overview" aria-label="Overview" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800"><div id="c62e2bf4-0455-461a-8816-5e66e4315fe5" class="w-full break-words py-2 text-base focus:outline-none text-slate-700  dark:text-slate-200">Overview</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="#heading-prerequisites" aria-label="Prerequisites" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="851dff37-fd27-41cd-b828-eb0ba56a7146" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Prerequisites</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="#heading-installing-hayride" aria-label="Installing Hayride" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="7a129beb-fd1a-41e5-a602-388021ed3f6a" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Installing Hayride</div></a></li></ul></li><li><a href="#heading-building-a-cli-agent" aria-label="Building a CLI Agent" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="5d1ec457-096e-4248-8576-4d29e46d34d9" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Building a CLI Agent</div></a><ul class="pl-4 dark:border-slate-800"><li><a href="#heading-defining-our-morph" aria-label="Defining Our Morph" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="d97e814c-4f20-4902-8f53-0d70fa9999a3" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Defining Our Morph</div></a></li><li><a href="#heading-project-setup" aria-label="Project Setup" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="294da59e-c03c-4d11-9bad-251d1d8e5516" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Project Setup</div></a></li><li><a href="#heading-cli-application" aria-label="CLI Application" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="b4ac9c3c-ee04-49f3-ba49-2467d4f0a542" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">CLI Application</div></a></li><li><a href="#heading-build-composition-and-deployment" aria-label="Build Composition and Deployment" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="701498c3-5104-40f8-822e-2935909a0747" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Build Composition and Deployment</div></a></li></ul></li><li><a href="#heading-conclusion" aria-label="Conclusion" class="mb-1 flex items-center gap-x-2 rounded-lg px-2 focus:outline-none hover:bg-slate-100 focus:bg-slate-100 dark:hover:bg-slate-800 dark:focus:bg-slate-800 -mt-1"><span class="text-slate-400 dark:text-slate-500"><svg class="h-4 w-4 stroke-current" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6665 4L10.6665 8L6.6665 12"></path></svg></span><div id="9292c17a-23da-4664-b4ec-c5983894fbf8" class="w-full break-words py-2 text-base focus:outline-none text-slate-600 dark:text-slate-300">Conclusion</div></a></li></ul></li></ul></div></div><div id="post-content-parent" class="relative mb-10 pb-14"><div id="post-content-wrapper" class="prose prose-base mx-auto mb-10 min-h-30 break-words dark:prose-dark lg:prose-lg"><h1 id="heading-overview">Overview</h1>
<p><a target="_blank" href="https://blog.hayride.dev/sandboxing-ai">In our last post</a>, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.</p>
<p>Hayride leverages the <a target="_blank" href="https://webassembly.org/docs/security/">security</a> and <a target="_blank" href="https://webassembly.org/docs/security/">por</a><a target="_blank" href="https://webassembly.org/docs/portability/">tability</a> benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.</p>
<p>In a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using <strong>Golang</strong>, with a sprinkle of <strong>Rust</strong>, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.</p>
<p>If you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.</p>
<p>Here are some resources to get you up to speed on WebAssembly:</p>
<ul>
<li><p><a target="_blank" href="https://wasi.dev/">https://wasi.dev/</a></p>
</li>
<li><p><a target="_blank" href="https://component-model.bytecodealliance.org/introduction.html">https://component-model.bytecodealliance.org/introduction.html</a></p>
</li>
<li><p><a target="_blank" href="https://docs.hayride.dev/platform/concepts/wasm">https://docs.hayride.dev/platform/concepts/wasm</a></p>
</li>
</ul>
<p>Let’s dive in!</p>
<h2 id="heading-prerequisites">Prerequisites</h2>
<p>Before we can start implementing our application, several tools are required. Of note, Hayride leverages <a target="_blank" href="https://wasi.dev/interfaces#wasi-02">WASI Preview 2</a>, which is gaining support across various languages.</p>
<p>We’ll use the following tools in this post:</p>
<ul>
<li><p><a target="_blank" href="https://github.com/hayride-dev/releases">Hayride</a></p>
</li>
<li><p><a target="_blank" href="https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go">Wit-bindgen-go</a></p>
</li>
<li><p><a target="_blank" href="https://github.com/bytecodealliance/wit-deps">Wit-deps</a></p>
</li>
<li><p><a target="_blank" href="https://github.com/bytecodealliance/wac">Wac</a></p>
</li>
<li><p><a target="_blank" href="https://go.dev/doc/install">Go</a> version 1.23.0+</p>
</li>
<li><p><a target="_blank" href="https://tinygo.org/">TinyGo</a> version 0.33.0+</p>
</li>
<li><p><a target="_blank" href="https://www.rust-lang.org/tools/install">Rust +nightly</a></p>
</li>
<li><p><a target="_blank" href="https://github.com/bytecodealliance/cargo-component">Cargo component</a></p>
</li>
</ul>
<p>Please refer to the tools’ installation guides to get started.</p>
<h3 id="heading-installing-hayride">Installing Hayride</h3>
<p>The easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:</p>
<p><code>curl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash</code></p>
<p>This downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.</p>
<p>Windows users can visit our releases page to download the <a target="_blank" href="https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi">MSI installer</a> and use it to install Hayride.</p>
<p>After the installation completes, the hayride binary should be located in your path. You can verify the installation by running <code>hayride help</code> from your terminal.</p>
<p>Now that Hayride is installed, we can start developing an agent that can be deployed to Hayride!</p>
<h2 id="heading-building-a-cli-agent">Building a CLI Agent</h2>
<p>Hayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).</p>
<p>An <strong>interface</strong> describes a single-focused, composable contract through which components can interact with each other and with hosts.</p>
<p>Interfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., <strong>export</strong>) or whether external code must fulfill the interface for the component to call (i.e., <strong>import</strong>).</p>
<p>Interfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.</p>
<p>Here is an example of how Hayride defines an agent runner interface using WIT:</p>
<pre><code class="lang-go"><span class="hljs-keyword">package</span> hayride:ai@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;

<span class="hljs-keyword">interface</span> runner {
    use types.{message};
    use agents.{agent};
    use wasi:io/streams@<span class="hljs-number">0.2</span><span class="hljs-number">.0</span>.{output-stream};

    enum error-code {
        invoke-error,
        unknown
    }

    resource error {
        code: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">error</span>-<span class="hljs-title">code</span>;</span>
        data: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">string</span>;</span>
    }

    invoke: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(message: message, agent: borrow&lt;agent&gt;)</span> -&gt; <span class="hljs-title">result</span>&lt;<span class="hljs-title">list</span>&lt;<span class="hljs-title">message</span>&gt;, <span class="hljs-title">error</span>&gt;;</span>
    invoke-stream: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(message: message, writer: borrow&lt;output-stream&gt;, agent: borrow&lt;agent&gt;)</span> -&gt; <span class="hljs-title">result</span>&lt;_,<span class="hljs-title">error</span>&gt;;</span>
}
</code></pre>
<p>(<a target="_blank" href="https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit">https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit</a>)</p>
<p>The runner interface is responsible for invoking an agent and supplying a prompt or message.</p>
<p><strong>Runners</strong> define the agent loop as a function that describes how the agent executes.</p>
<p><strong>Agents</strong> are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.</p>
<p>Our agent interface in WIT is defined as follows:</p>
<pre><code class="lang-go"><span class="hljs-keyword">package</span> hayride:ai@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;

<span class="hljs-keyword">interface</span> agents {
    use types.{message};
    use context.{context};
    use model.{format};
    use hayride:mcp/tools@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>.{tools};
    use hayride:mcp/types@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>.{tool, call-tool-params, call-tool-result};
    use graph-stream.{graph-stream};
    use inference-stream.{graph-execution-context-stream};
    use wasi:io/streams@<span class="hljs-number">0.2</span><span class="hljs-number">.0</span>.{output-stream};

    enum error-code {
        capabilities-error,
        context-error,
        compute-error,
        execute-error,
        unknown
    }

    resource error {
        code: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">error</span>-<span class="hljs-title">code</span>;</span>
        data: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">string</span>;</span>
    }

    resource agent {
        constructor(name: <span class="hljs-keyword">string</span>, instruction: <span class="hljs-keyword">string</span>, format: format, graph: graph-execution-context-stream, tools: option&lt;tools&gt;, context: option&lt;context&gt;);
        name: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">string</span>;</span>
        instruction: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">string</span>;</span>
        capabilities: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">result</span>&lt;<span class="hljs-title">list</span>&lt;<span class="hljs-title">tool</span>&gt;, <span class="hljs-title">error</span>&gt;;</span>
        context: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">result</span>&lt;<span class="hljs-title">list</span>&lt;<span class="hljs-title">message</span>&gt;, <span class="hljs-title">error</span>&gt;;</span>
        compute: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(message: message)</span> -&gt; <span class="hljs-title">result</span>&lt;<span class="hljs-title">message</span>, <span class="hljs-title">error</span>&gt;;</span>
        execute: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(params: call-tool-params)</span> -&gt; <span class="hljs-title">result</span>&lt;<span class="hljs-title">call</span>-<span class="hljs-title">tool</span>-<span class="hljs-title">result</span>, <span class="hljs-title">error</span>&gt;;</span>
    }
}
</code></pre>
<p>(<a target="_blank" href="https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit">https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit</a>)</p>
<p>Following the component model, these interfaces can be implemented externally by outside code and imported by our component.</p>
<p>For this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our <a target="_blank" href="https://github.com/hayride-dev/morphs/tree/main/components">morphs repository</a>.</p>
<p>In a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.</p>
<h3 id="heading-defining-our-morph">Defining Our Morph</h3>
<p>Hayride Morphs are the fundamental building blocks of applications. They can <strong>import</strong> functions to access external capabilities and can also <strong>export</strong> their capabilities to other morphs.</p>
<p>The term <strong>morph</strong> simply refers to a WebAssembly component that is designed to be composable and portable across different environments.</p>
<p>Our CLI Agent Morph can be described in WIT using <strong>worlds</strong>.</p>
<p>A WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.</p>
<p>Connecting up some or all of a component’s imports to other components’ matching exports is called <strong>composition</strong>.</p>
<p>Given this, we can define our component world as follows:</p>
<pre><code class="lang-go"><span class="hljs-keyword">package</span> hayride:example@<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>;

world cli {
    include hayride:wasip2/imports@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;
    include hayride:wasip2/exports@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;

    <span class="hljs-keyword">import</span> hayride:ai/runner@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;
    <span class="hljs-keyword">import</span> hayride:ai/model-repository@<span class="hljs-number">0.0</span><span class="hljs-number">.61</span>;
}
</code></pre>
<p>(<a target="_blank" href="https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2">https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2</a>)</p>
<p>Now that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.</p>
<h3 id="heading-project-setup">Project Setup</h3>
<p>First, we create our project’s directory layout:</p>
<p><code>mkdir hayride-example-agent</code></p>
<p>Since we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use <strong>go mod</strong> to initialize our application and dependencies:</p>
<p><code>go mod init</code></p>
<p>Next, we create a directory called wit:</p>
<p><code>mkdir wit</code></p>
<p>We use the world defined above and copy it to a file in our wit directory:</p>
<p><code>touch ./wit/world.wit</code></p>
<p>To use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using <strong>wit-deps</strong>.</p>
<p>Wit-deps requires a <code>deps.toml</code> to track dependencies. We can add it to our wit directory using the following command:</p>
<p><code>Touch ./wit/deps.toml</code></p>
<p>In the <code>deps.toml</code> file, add the following dependencies:</p>
<pre><code class="lang-ini"><span class="hljs-attr">wasip2</span> = <span class="hljs-string">"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz"</span>
<span class="hljs-attr">ai</span> = <span class="hljs-string">"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz"</span>
<span class="hljs-attr">mcp</span> = <span class="hljs-string">"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz"</span>
</code></pre>
<p>To pull these dependencies into our project, we use a tool called <strong>wit-deps.</strong></p>
<p>From the project’s root, run the following command:</p>
<p><code>wit-deps update</code></p>
<p>Next, we create a <code>main.go</code> file and start implementing our CLI application:</p>
<p><code>touch main.go</code></p>
<p>Now that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.</p>
<h3 id="heading-cli-application">CLI Application</h3>
<p>Our CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.</p>
<p>First, let’s start by creating the necessary objects using Hayride’s <a target="_blank" href="https://github.com/hayride-dev/bindings">bindings repository</a>.</p>
<p>In the <code>main.go</code> file, add the following lines of code:</p>
<pre><code class="lang-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bufio"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"strings"</span>

    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/agents"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/ctx"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/graph"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/models"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/models/repository"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/runner"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/mcp/tools"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/types"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/wasi/cli"</span>
    <span class="hljs-string">"go.bytecodealliance.org/cm"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    repo := repository.New()
    path, err := repo.DownloadModel(<span class="hljs-string">"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to download model:"</span>, err)
    }

    <span class="hljs-comment">// Initialize the context, tools, and model format</span>
    ctx, err := ctx.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create context:"</span>, err)
    }

    tools, err := tools.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create tools:"</span>, err)
    }

    format, err := models.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create model format:"</span>, err)
    }

    <span class="hljs-comment">// host provides a graph stream</span>
    inferenceStream, err := graph.LoadByName(path)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to load graph:"</span>, err)
    }

    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to initialize graph execution context stream:"</span>, err)
    }

    a, err := agents.New(
        format, graphExecutionCtxStream,
        agents.WithName(<span class="hljs-string">"Helpful Agent"</span>),
        agents.WithInstruction(<span class="hljs-string">"You are a helpful assistant. Answer the user's questions to the best of your ability."</span>),
        agents.WithContext(ctx),
        agents.WithTools(tools),
    )
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create agent:"</span>, err)
    }

    runner := runner.New()
}
</code></pre>
<p>This code simply creates the various objects that our runner and agent require to execute:</p>
<ul>
<li><p><strong>Repository:</strong> The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.</p>
</li>
<li><p><strong>Context</strong>: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.</p>
</li>
<li><p><strong>Tools</strong>: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.</p>
</li>
<li><p><strong>Format</strong>: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.</p>
</li>
<li><p><strong>GraphExecutionCtxStream</strong>: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of <a target="_blank" href="https://github.com/WebAssembly/wasi-nn/releases">wasi-nn</a> to allow for streaming responses.</p>
</li>
</ul>
<p>Next, we add the code to read from <strong>STDIN</strong> and create a <strong>STDOUT</strong> writer.</p>
<p>Since we are working with WebAssembly, we leverage WASI to pipe the terminal’s <strong>STDIN/STDOUT</strong> in our application.</p>
<p>While TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an <code>io.Writer</code> when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.</p>
<p>To avoid this limitation, we have implemented a few WASI helpers in the <a target="_blank" href="https://github.com/hayride-dev/bindings/tree/main/go/wasi">bindings repository</a>. The main helper to leverage is our implementation of the <a target="_blank" href="https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit"><strong>wasi-cli</strong></a> interface.</p>
<p>Using our bindings, we can create an <code>io.Writer</code> that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:</p>
<pre><code class="lang-go">writer := cli.GetStdout(<span class="hljs-literal">true</span>)
reader := bufio.NewReader(os.Stdin)
</code></pre>
<p>Lastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:</p>
<pre><code class="lang-go">fmt.Println(<span class="hljs-string">"What can I help with?"</span>)
<span class="hljs-keyword">for</span> {
    input, _ := reader.ReadString(<span class="hljs-string">'\n'</span>)
    prompt := strings.TrimSpace(input)
    <span class="hljs-keyword">if</span> strings.ToLower(prompt) == <span class="hljs-string">"exit"</span> {
        fmt.Println(<span class="hljs-string">"Goodbye!"</span>)
        <span class="hljs-keyword">break</span>
    }

    msg := types.Message{
        Role: types.RoleUser,
        Content: cm.ToList([]types.MessageContent{
            types.NewMessageContent(types.Text(input)),
        }),
    }

    err := runner.InvokeStream(msg, writer, a)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        fmt.Println(<span class="hljs-string">"error invoking agent:"</span>, err)
        os.Exit(<span class="hljs-number">1</span>)
    }

    fmt.Println(<span class="hljs-string">"\nWhat else can I help with? (type 'exit' to quit)"</span>)
}
</code></pre>
<p>The runner’s <strong>InvokeStream</strong> function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.</p>
<p>There are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the <a target="_blank" href="https://wasi.dev/roadmap?utm_source=chatgpt.com">wasi roadmap</a>.</p>
<p>The full code looks like this:</p>
<pre><code class="lang-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bufio"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"os"</span>
    <span class="hljs-string">"strings"</span>

    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/agents"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/ctx"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/graph"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/models"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/models/repository"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/ai/runner"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/mcp/tools"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/hayride/types"</span>
    <span class="hljs-string">"github.com/hayride-dev/bindings/go/wasi/cli"</span>
    <span class="hljs-string">"go.bytecodealliance.org/cm"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    repo := repository.New()
    path, err := repo.DownloadModel(<span class="hljs-string">"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to download model:"</span>, err)
    }

    <span class="hljs-comment">// Initialize the context, tools, and model format</span>
    ctx, err := ctx.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create context:"</span>, err)
    }

    tools, err := tools.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create tools:"</span>, err)
    }

    format, err := models.New()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create model format:"</span>, err)
    }

    <span class="hljs-comment">// host provides a graph stream</span>
    inferenceStream, err := graph.LoadByName(path)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to load graph:"</span>, err)
    }

    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to initialize graph execution context stream:"</span>, err)
    }

    a, err := agents.New(
        format, graphExecutionCtxStream,
        agents.WithName(<span class="hljs-string">"Helpful Agent"</span>),
        agents.WithInstruction(<span class="hljs-string">"You are a helpful assistant. Answer the user's questions to the best of your ability."</span>),
        agents.WithContext(ctx),
        agents.WithTools(tools),
    )
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"failed to create agent:"</span>, err)
    }

    runner := runner.New()

    writer := cli.GetStdout(<span class="hljs-literal">true</span>)
    reader := bufio.NewReader(os.Stdin)

    fmt.Println(<span class="hljs-string">"What can I help with?"</span>)
    <span class="hljs-keyword">for</span> {
        input, _ := reader.ReadString(<span class="hljs-string">'\n'</span>)
        prompt := strings.TrimSpace(input)
        <span class="hljs-keyword">if</span> strings.ToLower(prompt) == <span class="hljs-string">"exit"</span> {
            fmt.Println(<span class="hljs-string">"Goodbye!"</span>)
            <span class="hljs-keyword">break</span>
        }

        msg := types.Message{
            Role: types.RoleUser,
            Content: cm.ToList([]types.MessageContent{
                types.NewMessageContent(types.Text(input)),
            }),
        }

        err := runner.InvokeStream(msg, writer, a)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            fmt.Println(<span class="hljs-string">"error invoking agent:"</span>, err)
            os.Exit(<span class="hljs-number">1</span>)
        }

        fmt.Println(<span class="hljs-string">"\nWhat else can I help with? (type 'exit' to quit)"</span>)
    }
}
</code></pre>
<p>(<a target="_blank" href="https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go">https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go</a>)</p>
<p>All that’s left is to build and deploy our agent onto Hayride!</p>
<p>We’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.</p>
<h3 id="heading-build-composition-and-deployment">Build Composition and Deployment</h3>
<p>To compose our CLI with the existing Wasm components supplied by Hayride, we use <strong>WAC,</strong> a tool for composing WebAssembly Components together. The source code for these components can be found in our <a target="_blank" href="https://github.com/hayride-dev/morphs/tree/main/components">morphs repository</a>.</p>
<p>The full language guide for WAC can be found <a target="_blank" href="https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md">here</a>.</p>
<p>We start by creating a <code>cli.wac</code> with the following content:</p>
<pre><code class="lang-bash">package hayride:example;

<span class="hljs-built_in">let</span> context = new hayride:inmemory@0.0.1 {...}; 
<span class="hljs-built_in">let</span> llama = new hayride:llama31@0.0.1 {...};
<span class="hljs-built_in">let</span> tools = new hayride:default-tools@0.0.1 {...};

<span class="hljs-built_in">let</span> agent = new hayride:default-agent@0.0.1 {
  context: context.context,
  model: llama.model,
  tools: tools.tools,
  ...
};

<span class="hljs-built_in">let</span> runner = new hayride:default-runner@0.0.1 {
  agents: agent.agents,
  ...
};

<span class="hljs-built_in">let</span> cli = new hayride:cli@0.0.1 {
  context: context.context,
  model: llama.model,
  tools: tools.tools,
  agents: agent.agents,
  runner: runner.runner,
  ...
};

<span class="hljs-built_in">export</span> cli...;
</code></pre>
<p>This file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.</p>
<p>In the above file, we are using the following Hayride Morphs:</p>
<ul>
<li><p><a href="hayride:inmemory@0.0.1" class="autolinkedURL autolinkedURL-url" target="_blank">hayride:inmemory@0.0.1</a></p>
</li>
<li><p><a href="hayride:llama31@0.0.1" class="autolinkedURL autolinkedURL-url" target="_blank">hayride:llama31@0.0.1</a></p>
</li>
<li><p><a href="hayride:default-tools@0.0.1" class="autolinkedURL autolinkedURL-url" target="_blank">hayride:default-tools@0.0.1</a></p>
</li>
<li><p><a href="hayride:default-agent@0.0.1" class="autolinkedURL autolinkedURL-url" target="_blank">hayride:default-agent@0.0.1</a></p>
</li>
<li><p><a href="hayride:default-runner@0.0.1" class="autolinkedURL autolinkedURL-url" target="_blank">hayride:default-runner@0.0.1</a></p>
</li>
</ul>
<p>Using these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.</p>
<p>Hayride has built-in support for WAC files, and we can execute our composition with the following command:</p>
<p><code>hayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm</code></p>
<p>Once we have the <code>composed-cli-agent.wasm</code> file, we can register it with Hayride. This makes the morph available for future composition and direct execution.</p>
<p><code>hayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1</code></p>
<p>All that’s left is to execute our morph:<br /><code>hayride cast --package hayride:composed-cli-agent@0.0.1 -it</code></p>
<p>This command launches our CLI:</p>
<p><img data-zoomable="true" loading="lazy" src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK" alt /></p>
<h2 id="heading-conclusion">Conclusion</h2>
<p>In this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.</p>
<p>In our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.</p>
<p>To stay informed about future developments, follow us on <a target="_blank" href="https://x.com/HayrideDev">X</a> and <a target="_blank" href="https://github.com/hayride-dev">GitHub</a>.</p>
</div></div><div class="mb-5 flex w-full flex-row flex-wrap justify-center md:mb-0"><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="/tag/golang?source=tags_bottom_blogs"><span>golang</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="/tag/webassembly?source=tags_bottom_blogs"><span>WebAssembly</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="/tag/ai?source=tags_bottom_blogs"><span>AI</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="/tag/ai-tools?source=tags_bottom_blogs"><span>#ai-tools</span></a><a class="mb-3 mr-3 rounded-lg border bg-slate-100 px-2 py-1 text-base font-medium text-slate-700 hover:bg-slate-200 dark:border-slate-800 dark:bg-slate-800 dark:text-slate-100 dark:hover:bg-slate-700" href="/tag/llm?source=tags_bottom_blogs"><span>llm</span></a></div></div></section></div><div class="absolute h-px w-px overflow-hidden" id="refNode1" style="top:100px;left:100px"> </div><div class="absolute left-0 top-0 h-px w-px overflow-hidden" id="refNode2"></div><div class="absolute z-50 mt-4 hidden"><div class="flex flex-row items-center rounded-lg border border-slate-300 bg-white p-4 text-slate-800 shadow-lg dark:border-white dark:bg-slate-800 dark:text-slate-300"><span class="mr-3 block">Share this</span><a href="https://twitter.com/share?url=https%3A%2F%2Fblog.hayride.dev%2Fcomposable-agents&amp;text=%20%40elewis" class="rounded-full border border-transparent py-1 font-medium text-slate-700 dark:text-slate-200 hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm" variant="transparent" target="_blank" rel="noopener"><svg class="h-6 w-6 stroke-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.643 13.346L4.26862 4.86856C3.85863 4.32329 4.2478 3.54408 4.93001 3.54431L7.2184 3.54508C7.47633 3.54517 7.71945 3.66557 7.87585 3.87066L12.9065 10.4675M10.643 13.346L5.19311 20.5093M10.643 13.346L15.8028 20.077C15.9588 20.2805 16.2003 20.4001 16.4567 20.4009L18.7925 20.4082C19.4778 20.4104 19.8683 19.6261 19.4536 19.0805L12.9065 10.4675M12.9065 10.4675L18.2181 3.50928" stroke-width="1.5" stroke-linecap="round"></path></svg></a><a href="http://www.reddit.com/submit?title=Composable%20Agents&amp;selftext=true&amp;text=%20https%3A%2F%2Fblog.hayride.dev%2Fcomposable-agents" class="rounded-full border border-transparent py-1 font-medium hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm text-red-600 dark:text-red-600" variant="transparent" target="_blank" rel="noopener"><svg class="h-6 w-6 fill-current" viewBox="0 0 512 512"><path d="M201.5 305.5c-13.8 0-24.9-11.1-24.9-24.6 0-13.8 11.1-24.9 24.9-24.9 13.6 0 24.6 11.1 24.6 24.9 0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4 0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7 0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9 0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5 0 52.6 59.2 95.2 132 95.2 73.1 0 132.3-42.6 132.3-95.2 0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6 0-2.2-2.2-6.1-2.2-8.3 0-2.5 2.5-2.5 6.4 0 8.6 22.8 22.8 87.3 22.8 110.2 0 2.5-2.2 2.5-6.1 0-8.6-2.2-2.2-6.1-2.2-8.3 0zm7.7-75c-13.6 0-24.6 11.1-24.6 24.9 0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.1 24.9-24.6 0-13.8-11-24.9-24.9-24.9z"></path></svg></a><button class="rounded-full border border-transparent py-1 font-medium text-slate-700 dark:text-slate-200 hover:bg-slate-200 disabled:opacity-50 hover:dark:bg-slate-700 flex flex-row items-center focus:outline-none px-2 text-sm" type="button" variant="transparent" data-clipboard-text=" https://blog.hayride.dev/composable-agents" id="text-sharer"><svg class="h-6 w-6 fill-current" viewBox="0 0 384 512"><path d="M336 64h-88.6c.4-2.6.6-5.3.6-8 0-30.9-25.1-56-56-56s-56 25.1-56 56c0 2.7.2 5.4.6 8H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM192 32c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm160 432c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16h48v20c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12V96h48c8.8 0 16 7.2 16 16z"></path></svg></button></div></div><div class="container relative z-20 mx-auto grid grid-flow-row grid-cols-8 xl:gap-6 2xl:grid-cols-10"><div class="blog-comments-section-wrapper col-span-8 px-4 lg:col-span-6 lg:col-start-2 lg:px-0 xl:col-span-6 xl:col-start-2 2xl:col-span-6 2xl:col-start-3"></div></div></article></main></div></div></div><script type="text/javascript">
              var SUPPORTS_PASSIVE = false;
              try {
                var opts = Object.defineProperty({}, 'passive', {
                  get: function() {
                    SUPPORTS_PASSIVE = true;
                  }
                });
                window.addEventListener("testPassive", null, opts);
                window.removeEventListener("testPassive", null, opts);
              } catch (e) {}
            </script><script type="text/javascript">
              // Array.prototype.flat polyfill
              if (!Array.prototype.flat) {
                // eslint-disable-next-line no-extend-native
                Object.defineProperty(Array.prototype, 'flat', {
                  configurable: true,
                  writable: true,
                  value() {
                    // eslint-disable-next-line prefer-rest-params
                    const depth = typeof arguments[0] === 'undefined' ? 1 : Number(arguments[0]) || 0;
                    const result = [];
                    const { forEach } = result;

                    // eslint-disable-next-line no-var
                    var flatDeep = function (arr, depth) {
                      forEach.call(arr, (val) => {
                        if (depth > 0 && Array.isArray(val)) {
                          flatDeep(val, depth - 1);
                        } else {
                          result.push(val);
                        }
                      });
                    };

                    flatDeep(this, depth);
                    return result;
                  },
                });
              }
            </script><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"{\"_id\":\"688cedc0cc9d97047fda4fc7\",\"partOfPublication\":true,\"author\":{\"_id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"username\":\"elewis\",\"bio\":\"\u003cp\u003eCTO at Kochava, previously a software engineer at IBM. \u003c/p\u003e\\n\u003cp\u003eFounding Engineer for Vaunt and Hayride. \u003c/p\u003e\\n\u003cp\u003eI make grave mistakes all the time... everything seems to work out. Wasm, Wasm, Wasm...Wasm\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"https://elewis.dev/\",\"github\":\"https://github.com/elewis787\",\"twitter\":\"https://twitter.com/elewis787\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/elewis787/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"68541f2eb35e0480fa6966dc\",\"author\":{\"_id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"username\":\"elewis\"},\"badgePageEnabled\":true,\"description\":\"\",\"domain\":\"blog.hayride.dev\",\"domainStatus\":{\"ready\":true,\"certIssued\":true},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355712150/ce8b55fe-703f-427c-a478-676d75fb6530.png\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"publicMembersCount\":3,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png\",\"gaTrackingID\":\"\",\"gTagManagerID\":\"\",\"hasBadges\":false,\"headerColor\":\"\",\"hideMembersPage\":true,\"isTeam\":true,\"layout\":\"stacked\",\"membersPageEnabled\":false,\"menu\":[{\"_id\":\"686ecd07b6374d88e8285f60\",\"label\":\"docs\",\"type\":\"link\",\"url\":\"https://docs.hayride.dev/\"}],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":true,\"proTeamEnabled\":false,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1752092095732/dc6e4b98-d156-4a97-ab89-2329434b9d85.jpeg\",\"logo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png\",\"textSelectionSharerEnabled\":true,\"title\":\"Hayride\",\"urlPattern\":\"simple\",\"username\":\"hayride\",\"viewCountVisible\":true,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"\",\"github\":\"https://github.com/hayride-dev\",\"website\":\"https://hayride.dev\",\"hashnode\":\"\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"\",\"mastodon\":\"\",\"facebook\":\"\"},\"numPosts\":2,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"allowContributorEdits\":true,\"allowCrawlingByGPT\":false},\"tags\":[{\"_id\":\"56744721958ef13879b94e1c\",\"slug\":\"golang\",\"name\":\"golang\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b95043\",\"slug\":\"webassembly\",\"name\":\"WebAssembly\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744721958ef13879b9488e\",\"slug\":\"ai\",\"name\":\"AI\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"6347ba4bad721d4c5133e3c2\",\"slug\":\"ai-tools\",\"name\":\"#ai-tools\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"635ad52efe8087002dee4707\",\"slug\":\"llm\",\"name\":\"llm\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":0,\"replyCount\":0,\"contentMarkdown\":\"# Overview\\n\\n[In our last post](https://blog.hayride.dev/sandboxing-ai), we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\n\\nHayride leverages the [security](https://webassembly.org/docs/security/) and [por](https://webassembly.org/docs/security/)[tability](https://webassembly.org/docs/portability/) benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\\n\\nIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using **Golang**, with a sprinkle of **Rust**, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\\n\\nIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\\n\\nHere are some resources to get you up to speed on WebAssembly:\\n\\n* [https://wasi.dev/](https://wasi.dev/)\\n    \\n* [https://component-model.bytecodealliance.org/introduction.html](https://component-model.bytecodealliance.org/introduction.html)\\n    \\n* [https://docs.hayride.dev/platform/concepts/wasm](https://docs.hayride.dev/platform/concepts/wasm)\\n    \\n\\nLet’s dive in!\\n\\n## Prerequisites\\n\\nBefore we can start implementing our application, several tools are required. Of note, Hayride leverages [WASI Preview 2](https://wasi.dev/interfaces#wasi-02), which is gaining support across various languages.\\n\\nWe’ll use the following tools in this post:\\n\\n* [Hayride](https://github.com/hayride-dev/releases)\\n    \\n* [Wit-bindgen-go](https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go)\\n    \\n* [Wit-deps](https://github.com/bytecodealliance/wit-deps)\\n    \\n* [Wac](https://github.com/bytecodealliance/wac)\\n    \\n* [Go](https://go.dev/doc/install) version 1.23.0+\\n    \\n* [TinyGo](https://tinygo.org/) version 0.33.0+\\n    \\n* [Rust +nightly](https://www.rust-lang.org/tools/install)\\n    \\n* [Cargo component](https://github.com/bytecodealliance/cargo-component)\\n    \\n\\nPlease refer to the tools’ installation guides to get started.\\n\\n### Installing Hayride\\n\\nThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\\n\\n`curl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash`\\n\\nThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\\n\\nWindows users can visit our releases page to download the [MSI installer](https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi) and use it to install Hayride.\\n\\nAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running `hayride help` from your terminal.\\n\\nNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\\n\\n## Building a CLI Agent\\n\\nHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\\n\\nAn **interface** describes a single-focused, composable contract through which components can interact with each other and with hosts.\\n\\nInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., **export**) or whether external code must fulfill the interface for the component to call (i.e., **import**).\\n\\nInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\\n\\nHere is an example of how Hayride defines an agent runner interface using WIT:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    invoke: func(message: message, agent: borrow\u003cagent\u003e) -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n    invoke-stream: func(message: message, writer: borrow\u003coutput-stream\u003e, agent: borrow\u003cagent\u003e) -\u003e result\u003c_,error\u003e;\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit))\\n\\nThe runner interface is responsible for invoking an agent and supplying a prompt or message.\\n\\n**Runners** define the agent loop as a function that describes how the agent executes.\\n\\n**Agents** are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\\n\\nOur agent interface in WIT is defined as follows:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@0.0.61.{tools};\\n    use hayride:mcp/types@0.0.61.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    resource agent {\\n        constructor(name: string, instruction: string, format: format, graph: graph-execution-context-stream, tools: option\u003ctools\u003e, context: option\u003ccontext\u003e);\\n        name: func() -\u003e string;\\n        instruction: func() -\u003e string;\\n        capabilities: func() -\u003e result\u003clist\u003ctool\u003e, error\u003e;\\n        context: func() -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n        compute: func(message: message) -\u003e result\u003cmessage, error\u003e;\\n        execute: func(params: call-tool-params) -\u003e result\u003ccall-tool-result, error\u003e;\\n    }\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit))\\n\\nFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\\n\\nFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\\n\\n### Defining Our Morph\\n\\nHayride Morphs are the fundamental building blocks of applications. They can **import** functions to access external capabilities and can also **export** their capabilities to other morphs.\\n\\nThe term **morph** simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\\n\\nOur CLI Agent Morph can be described in WIT using **worlds**.\\n\\nA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\\n\\nConnecting up some or all of a component’s imports to other components’ matching exports is called **composition**.\\n\\nGiven this, we can define our component world as follows:\\n\\n```go\\npackage hayride:example@0.0.1;\\n\\nworld cli {\\n    include hayride:wasip2/imports@0.0.61;\\n    include hayride:wasip2/exports@0.0.61;\\n    \\n    import hayride:ai/runner@0.0.61;\\n    import hayride:ai/model-repository@0.0.61;\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2))\\n\\nNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\\n\\n### Project Setup\\n\\nFirst, we create our project’s directory layout:\\n\\n`mkdir hayride-example-agent`\\n\\nSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use **go mod** to initialize our application and dependencies:\\n\\n`go mod init`\\n\\nNext, we create a directory called wit:\\n\\n`mkdir wit`\\n\\nWe use the world defined above and copy it to a file in our wit directory:\\n\\n`touch ./wit/world.wit`\\n\\nTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using **wit-deps**.\\n\\nWit-deps requires a `deps.toml` to track dependencies. We can add it to our wit directory using the following command:\\n\\n`Touch ./wit/deps.toml`\\n\\nIn the `deps.toml` file, add the following dependencies:\\n\\n```ini\\nwasip2 = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\\nai = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\\nmcp = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\\n```\\n\\nTo pull these dependencies into our project, we use a tool called **wit-deps.**\\n\\nFrom the project’s root, run the following command:\\n\\n`wit-deps update`\\n\\nNext, we create a `main.go` file and start implementing our CLI application:\\n\\n`touch main.go`\\n\\nNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\\n\\n### CLI Application\\n\\nOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\\n\\nFirst, let’s start by creating the necessary objects using Hayride’s [bindings repository](https://github.com/hayride-dev/bindings).\\n\\nIn the `main.go` file, add the following lines of code:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n}\\n```\\n\\nThis code simply creates the various objects that our runner and agent require to execute:\\n\\n* **Repository:** The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\\n    \\n* **Context**: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\\n    \\n* **Tools**: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\\n    \\n* **Format**: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\\n    \\n* **GraphExecutionCtxStream**: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of [wasi-nn](https://github.com/WebAssembly/wasi-nn/releases) to allow for streaming responses.\\n    \\n\\nNext, we add the code to read from **STDIN** and create a **STDOUT** writer.\\n\\nSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s **STDIN/STDOUT** in our application.\\n\\nWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an `io.Writer` when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\\n\\nTo avoid this limitation, we have implemented a few WASI helpers in the [bindings repository](https://github.com/hayride-dev/bindings/tree/main/go/wasi). The main helper to leverage is our implementation of the [**wasi-cli**](https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit) interface.\\n\\nUsing our bindings, we can create an `io.Writer` that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\\n\\n```go\\nwriter := cli.GetStdout(true)\\nreader := bufio.NewReader(os.Stdin)\\n```\\n\\nLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\\n\\n```go\\nfmt.Println(\\\"What can I help with?\\\")\\nfor {\\n\\tinput, _ := reader.ReadString('\\\\n')\\n\\tprompt := strings.TrimSpace(input)\\n\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\tbreak\\n\\t}\\n\\n\\tmsg := types.Message{\\n\\t\\tRole: types.RoleUser,\\n\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t}),\\n\\t}\\n\\n\\terr := runner.InvokeStream(msg, writer, a)\\n\\tif err != nil {\\n\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n\\n\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n}\\n```\\n\\nThe runner’s **InvokeStream** function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\\n\\nThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the [wasi roadmap](https://wasi.dev/roadmap?utm_source=chatgpt.com).\\n\\nThe full code looks like this:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n\\n\\twriter := cli.GetStdout(true)\\n\\treader := bufio.NewReader(os.Stdin)\\n\\n\\tfmt.Println(\\\"What can I help with?\\\")\\n\\tfor {\\n\\t\\tinput, _ := reader.ReadString('\\\\n')\\n\\t\\tprompt := strings.TrimSpace(input)\\n\\t\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tmsg := types.Message{\\n\\t\\t\\tRole: types.RoleUser,\\n\\t\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t\\t}),\\n\\t\\t}\\n\\n\\t\\terr := runner.InvokeStream(msg, writer, a)\\n\\t\\tif err != nil {\\n\\t\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\t\\tos.Exit(1)\\n\\t\\t}\\n\\n\\t\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n\\t}\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go))\\n\\nAll that’s left is to build and deploy our agent onto Hayride!\\n\\nWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\\n\\n### Build Composition and Deployment\\n\\nTo compose our CLI with the existing Wasm components supplied by Hayride, we use **WAC,** a tool for composing WebAssembly Components together. The source code for these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nThe full language guide for WAC can be found [here](https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md).\\n\\nWe start by creating a `cli.wac` with the following content:\\n\\n```bash\\npackage hayride:example;\\n\\nlet context = new hayride:inmemory@0.0.1 {...}; \\nlet llama = new hayride:llama31@0.0.1 {...};\\nlet tools = new hayride:default-tools@0.0.1 {...};\\n\\nlet agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\nlet runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\nlet cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\nexport cli...;\\n```\\n\\nThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\\n\\nIn the above file, we are using the following Hayride Morphs:\\n\\n* hayride:inmemory@0.0.1\\n    \\n* hayride:llama31@0.0.1\\n    \\n* hayride:default-tools@0.0.1\\n    \\n* hayride:default-agent@0.0.1\\n    \\n* hayride:default-runner@0.0.1\\n    \\n\\nUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\\n\\nHayride has built-in support for WAC files, and we can execute our composition with the following command:\\n\\n`hayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm`\\n\\nOnce we have the `composed-cli-agent.wasm` file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\\n\\n`hayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1`\\n\\nAll that’s left is to execute our morph:   \\n`hayride cast --package hayride:composed-cli-agent@0.0.1 -it`\\n\\nThis command launches our CLI:\\n\\n![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK align=\\\"left\\\")\\n\\n## Conclusion\\n\\nIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\\n\\nIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\\n\\nTo stay informed about future developments, follow us on [X](https://x.com/HayrideDev) and [GitHub](https://github.com/hayride-dev).\",\"content\":\"\u003ch1 id=\\\"heading-overview\\\"\u003eOverview\u003c/h1\u003e\\n\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://blog.hayride.dev/sandboxing-ai\\\"\u003eIn our last post\u003c/a\u003e, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\u003c/p\u003e\\n\u003cp\u003eHayride leverages the \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003esecurity\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003epor\u003c/a\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/portability/\\\"\u003etability\u003c/a\u003e benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\u003c/p\u003e\\n\u003cp\u003eIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using \u003cstrong\u003eGolang\u003c/strong\u003e, with a sprinkle of \u003cstrong\u003eRust\u003c/strong\u003e, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\u003c/p\u003e\\n\u003cp\u003eIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\u003c/p\u003e\\n\u003cp\u003eHere are some resources to get you up to speed on WebAssembly:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/\\\"\u003ehttps://wasi.dev/\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://component-model.bytecodealliance.org/introduction.html\\\"\u003ehttps://component-model.bytecodealliance.org/introduction.html\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://docs.hayride.dev/platform/concepts/wasm\\\"\u003ehttps://docs.hayride.dev/platform/concepts/wasm\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eLet’s dive in!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-prerequisites\\\"\u003ePrerequisites\u003c/h2\u003e\\n\u003cp\u003eBefore we can start implementing our application, several tools are required. Of note, Hayride leverages \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/interfaces#wasi-02\\\"\u003eWASI Preview 2\u003c/a\u003e, which is gaining support across various languages.\u003c/p\u003e\\n\u003cp\u003eWe’ll use the following tools in this post:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases\\\"\u003eHayride\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go\\\"\u003eWit-bindgen-go\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wit-deps\\\"\u003eWit-deps\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac\\\"\u003eWac\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://go.dev/doc/install\\\"\u003eGo\u003c/a\u003e version 1.23.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://tinygo.org/\\\"\u003eTinyGo\u003c/a\u003e version 0.33.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://www.rust-lang.org/tools/install\\\"\u003eRust +nightly\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/cargo-component\\\"\u003eCargo component\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003ePlease refer to the tools’ installation guides to get started.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-installing-hayride\\\"\u003eInstalling Hayride\u003c/h3\u003e\\n\u003cp\u003eThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ecurl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\u003c/p\u003e\\n\u003cp\u003eWindows users can visit our releases page to download the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi\\\"\u003eMSI installer\u003c/a\u003e and use it to install Hayride.\u003c/p\u003e\\n\u003cp\u003eAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running \u003ccode\u003ehayride help\u003c/code\u003e from your terminal.\u003c/p\u003e\\n\u003cp\u003eNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-building-a-cli-agent\\\"\u003eBuilding a CLI Agent\u003c/h2\u003e\\n\u003cp\u003eHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\u003c/p\u003e\\n\u003cp\u003eAn \u003cstrong\u003einterface\u003c/strong\u003e describes a single-focused, composable contract through which components can interact with each other and with hosts.\u003c/p\u003e\\n\u003cp\u003eInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., \u003cstrong\u003eexport\u003c/strong\u003e) or whether external code must fulfill the interface for the component to call (i.e., \u003cstrong\u003eimport\u003c/strong\u003e).\u003c/p\u003e\\n\u003cp\u003eInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\u003c/p\u003e\\n\u003cp\u003eHere is an example of how Hayride defines an agent runner interface using WIT:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    invoke: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    invoke-stream: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, writer: borrow\u0026lt;output-stream\u0026gt;, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;_,\u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eThe runner interface is responsible for invoking an agent and supplying a prompt or message.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eRunners\u003c/strong\u003e define the agent loop as a function that describes how the agent executes.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAgents\u003c/strong\u003e are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\u003c/p\u003e\\n\u003cp\u003eOur agent interface in WIT is defined as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tools};\\n    use hayride:mcp/types@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    resource agent {\\n        constructor(name: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, instruction: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, format: format, graph: graph-execution-context-stream, tools: option\u0026lt;tools\u0026gt;, context: option\u0026lt;context\u0026gt;);\\n        name: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        instruction: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        capabilities: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        context: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        compute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        execute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(params: call-tool-params)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003ecall\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\u003c/p\u003e\\n\u003cp\u003eFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-defining-our-morph\\\"\u003eDefining Our Morph\u003c/h3\u003e\\n\u003cp\u003eHayride Morphs are the fundamental building blocks of applications. They can \u003cstrong\u003eimport\u003c/strong\u003e functions to access external capabilities and can also \u003cstrong\u003eexport\u003c/strong\u003e their capabilities to other morphs.\u003c/p\u003e\\n\u003cp\u003eThe term \u003cstrong\u003emorph\u003c/strong\u003e simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\u003c/p\u003e\\n\u003cp\u003eOur CLI Agent Morph can be described in WIT using \u003cstrong\u003eworlds\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\u003c/p\u003e\\n\u003cp\u003eConnecting up some or all of a component’s imports to other components’ matching exports is called \u003cstrong\u003ecomposition\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eGiven this, we can define our component world as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:example@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.1\u003c/span\u003e;\\n\\nworld cli {\\n    include hayride:wasip2/imports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    include hayride:wasip2/exports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/runner@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/model-repository@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-project-setup\\\"\u003eProject Setup\u003c/h3\u003e\\n\u003cp\u003eFirst, we create our project’s directory layout:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir hayride-example-agent\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use \u003cstrong\u003ego mod\u003c/strong\u003e to initialize our application and dependencies:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ego mod init\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a directory called wit:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eWe use the world defined above and copy it to a file in our wit directory:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch ./wit/world.wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using \u003cstrong\u003ewit-deps\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eWit-deps requires a \u003ccode\u003edeps.toml\u003c/code\u003e to track dependencies. We can add it to our wit directory using the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003eTouch ./wit/deps.toml\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003edeps.toml\u003c/code\u003e file, add the following dependencies:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-ini\\\"\u003e\u003cspan class=\\\"hljs-attr\\\"\u003ewasip2\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003eai\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003emcp\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eTo pull these dependencies into our project, we use a tool called \u003cstrong\u003ewit-deps.\u003c/strong\u003e\u003c/p\u003e\\n\u003cp\u003eFrom the project’s root, run the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ewit-deps update\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a \u003ccode\u003emain.go\u003c/code\u003e file and start implementing our CLI application:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch main.go\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-cli-application\\\"\u003eCLI Application\u003c/h3\u003e\\n\u003cp\u003eOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\u003c/p\u003e\\n\u003cp\u003eFirst, let’s start by creating the necessary objects using Hayride’s \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings\\\"\u003ebindings repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003emain.go\u003c/code\u003e file, add the following lines of code:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis code simply creates the various objects that our runner and agent require to execute:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eContext\u003c/strong\u003e: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTools\u003c/strong\u003e: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eFormat\u003c/strong\u003e: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eGraphExecutionCtxStream\u003c/strong\u003e: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-nn/releases\\\"\u003ewasi-nn\u003c/a\u003e to allow for streaming responses.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eNext, we add the code to read from \u003cstrong\u003eSTDIN\u003c/strong\u003e and create a \u003cstrong\u003eSTDOUT\u003c/strong\u003e writer.\u003c/p\u003e\\n\u003cp\u003eSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s \u003cstrong\u003eSTDIN/STDOUT\u003c/strong\u003e in our application.\u003c/p\u003e\\n\u003cp\u003eWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an \u003ccode\u003eio.Writer\u003c/code\u003e when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\u003c/p\u003e\\n\u003cp\u003eTo avoid this limitation, we have implemented a few WASI helpers in the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings/tree/main/go/wasi\\\"\u003ebindings repository\u003c/a\u003e. The main helper to leverage is our implementation of the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit\\\"\u003e\u003cstrong\u003ewasi-cli\u003c/strong\u003e\u003c/a\u003e interface.\u003c/p\u003e\\n\u003cp\u003eUsing our bindings, we can create an \u003ccode\u003eio.Writer\u003c/code\u003e that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003ewriter := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\nreader := bufio.NewReader(os.Stdin)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003efmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n    input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n    prompt := strings.TrimSpace(input)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n    }\\n\\n    msg := types.Message{\\n        Role: types.RoleUser,\\n        Content: cm.ToList([]types.MessageContent{\\n            types.NewMessageContent(types.Text(input)),\\n        }),\\n    }\\n\\n    err := runner.InvokeStream(msg, writer, a)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n        os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n    }\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe runner’s \u003cstrong\u003eInvokeStream\u003c/strong\u003e function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\u003c/p\u003e\\n\u003cp\u003eThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/roadmap?utm_source=chatgpt.com\\\"\u003ewasi roadmap\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full code looks like this:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n\\n    writer := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\n    reader := bufio.NewReader(os.Stdin)\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n        input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n        prompt := strings.TrimSpace(input)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n            \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n        }\\n\\n        msg := types.Message{\\n            Role: types.RoleUser,\\n            Content: cm.ToList([]types.MessageContent{\\n                types.NewMessageContent(types.Text(input)),\\n            }),\\n        }\\n\\n        err := runner.InvokeStream(msg, writer, a)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n            os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n        }\\n\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to build and deploy our agent onto Hayride!\u003c/p\u003e\\n\u003cp\u003eWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-build-composition-and-deployment\\\"\u003eBuild Composition and Deployment\u003c/h3\u003e\\n\u003cp\u003eTo compose our CLI with the existing Wasm components supplied by Hayride, we use \u003cstrong\u003eWAC,\u003c/strong\u003e a tool for composing WebAssembly Components together. The source code for these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full language guide for WAC can be found \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md\\\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eWe start by creating a \u003ccode\u003ecli.wac\u003c/code\u003e with the following content:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-bash\\\"\u003epackage hayride:example;\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e context = new hayride:inmemory@0.0.1 {...}; \\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e llama = new hayride:llama31@0.0.1 {...};\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e tools = new hayride:default-tools@0.0.1 {...};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003eexport\u003c/span\u003e cli...;\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\u003c/p\u003e\\n\u003cp\u003eIn the above file, we are using the following Hayride Morphs:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:inmemory@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:inmemory@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:llama31@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:llama31@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-tools@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-tools@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-agent@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-agent@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-runner@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-runner@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\u003c/p\u003e\\n\u003cp\u003eHayride has built-in support for WAC files, and we can execute our composition with the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eOnce we have the \u003ccode\u003ecomposed-cli-agent.wasm\u003c/code\u003e file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to execute our morph:\u003cbr /\u003e\u003ccode\u003ehayride cast --package hayride:composed-cli-agent@0.0.1 -it\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis command launches our CLI:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK\\\" alt /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h2\u003e\\n\u003cp\u003eIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\u003c/p\u003e\\n\u003cp\u003eIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\u003c/p\u003e\\n\u003cp\u003eTo stay informed about future developments, follow us on \u003ca target=\\\"_blank\\\" href=\\\"https://x.com/HayrideDev\\\"\u003eX\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev\\\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\\n\",\"cuid\":\"cmdt1trnh000o02l83zqf2foo\",\"views\":494,\"title\":\"Composable Agents\",\"slug\":\"composable-agents\",\"dateAdded\":\"2025-08-01T16:39:28.061Z\",\"dateUpdated\":\"2025-08-01T19:21:45.491Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"Overview\\nIn our last post, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\nHayride leverages the security and portability benefits offered by WebAssembly, making it an id...\",\"isFollowing\":false,\"totalReactions\":10,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":11,\"sB\":false,\"isAMA\":false,\"subtitle\":\"It’s morphing time!\",\"isPartOfSeries\":false,\"hasTags\":true,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066340300/28af3dcf-9f58-4299-b182-9be5216337bc.jpeg\",\"metaTitle\":\"Composable Agents\",\"metaDescription\":\"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":false,\"hasLatex\":false,\"stickCoverToBottom\":false,\"hideBadges\":false,\"badges\":[],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":true,\"enableToc\":true,\"toc\":[[{\"id\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\",\"level\":1,\"slug\":\"overview\",\"title\":\"Overview\",\"parentId\":null}],[{\"id\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\",\"level\":2,\"slug\":\"prerequisites\",\"title\":\"Prerequisites\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}],[{\"id\":\"7a129beb-fd1a-41e5-a602-388021ed3f6a\",\"level\":3,\"slug\":\"installing-hayride\",\"title\":\"Installing Hayride\",\"parentId\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\"}],[{\"id\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\",\"level\":2,\"slug\":\"building-a-cli-agent\",\"title\":\"Building a CLI Agent\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}],[{\"id\":\"d97e814c-4f20-4902-8f53-0d70fa9999a3\",\"level\":3,\"slug\":\"defining-our-morph\",\"title\":\"Defining Our Morph\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"294da59e-c03c-4d11-9bad-251d1d8e5516\",\"level\":3,\"slug\":\"project-setup\",\"title\":\"Project Setup\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"b4ac9c3c-ee04-49f3-ba49-2467d4f0a542\",\"level\":3,\"slug\":\"cli-application\",\"title\":\"CLI Application\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"701498c3-5104-40f8-822e-2935909a0747\",\"level\":3,\"slug\":\"build-composition-and-deployment\",\"title\":\"Build Composition and Deployment\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"9292c17a-23da-4664-b4ec-c5983894fbf8\",\"level\":2,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}]],\"noIndex\":false}","publication":"{\"__typename\":\"Publication\",\"id\":\"68541f2eb35e0480fa6966dc\",\"url\":\"https://blog.hayride.dev\",\"canonicalURL\":\"https://blog.hayride.dev\",\"urlPattern\":\"SIMPLE\",\"title\":\"Hayride\",\"displayTitle\":null,\"hasBadges\":false,\"descriptionSEO\":null,\"publicMembers\":{\"totalDocuments\":3},\"about\":null,\"features\":{\"proTeam\":{\"isEnabled\":false},\"newsletter\":{\"isEnabled\":true},\"viewCount\":{\"isEnabled\":true},\"readTime\":{\"isEnabled\":true},\"textSelectionSharer\":{\"isEnabled\":true},\"customCSS\":{\"isEnabled\":false,\"published\":null,\"draft\":null},\"gptBotCrawling\":{\"__typename\":\"GPTBotCrawlingFeature\",\"isEnabled\":false}},\"metaTags\":null,\"ogMetaData\":{\"image\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1752092095732/dc6e4b98-d156-4a97-ab89-2329434b9d85.jpeg\"},\"author\":{\"__typename\":\"User\",\"id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"username\":\"elewis\",\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\"},\"preferences\":{\"__typename\":\"Preferences\",\"logo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png\",\"darkMode\":{\"__typename\":\"DarkModePreferences\",\"logo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355712150/ce8b55fe-703f-427c-a478-676d75fb6530.png\",\"enabled\":false},\"navbarItems\":[{\"__typename\":\"PublicationNavbarItem\",\"id\":\"686ecd07b6374d88e8285f60\",\"label\":\"docs\",\"url\":\"https://docs.hayride.dev/\",\"type\":\"link\",\"series\":null,\"page\":null}],\"enabledPages\":{\"__typename\":\"PagesPreferences\",\"badges\":false,\"newsletter\":true,\"members\":false},\"layout\":\"stacked\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false},\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png\",\"headerColor\":null,\"integrations\":{\"fbPixelID\":null,\"fathomSiteID\":null,\"fathomCustomDomainEnabled\":null,\"fathomCustomDomain\":null,\"hotjarSiteID\":null,\"matomoSiteID\":null,\"matomoURL\":null,\"gaTrackingID\":null,\"gTagManagerID\":null,\"plausibleAnalyticsEnabled\":null,\"wmPaymentPointer\":null,\"koalaPublicKey\":null,\"msClarityID\":null},\"imprintV2\":null,\"postsCount\":{\"totalDocuments\":2},\"isTeam\":true,\"links\":{\"twitter\":null,\"instagram\":null,\"github\":\"https://github.com/hayride-dev\",\"website\":\"https://hayride.dev\",\"hashnode\":null,\"youtube\":null,\"dailydev\":null,\"linkedin\":null,\"mastodon\":null,\"facebook\":null,\"bluesky\":null},\"domainInfo\":{\"__typename\":\"DomainInfo\",\"hashnodeSubdomain\":\"hayride\",\"domain\":{\"__typename\":\"DomainStatus\",\"host\":\"blog.hayride.dev\",\"ready\":true},\"wwwPrefixedDomain\":null},\"redirectionRules\":[],\"totalRecommendedPublications\":0,\"sponsorship\":{\"content\":null,\"stripe\":null},\"allowContributorEdits\":true,\"rssImport\":null,\"post\":{\"id\":\"688cedc0cc9d97047fda4fc7\",\"cuid\":\"cmdt1trnh000o02l83zqf2foo\",\"title\":\"Composable Agents\",\"subtitle\":\"It’s morphing time!\",\"slug\":\"composable-agents\",\"brief\":\"Overview\\nIn our last post, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\nHayride leverages the security and portability benefits offered by WebAssembly, making it an id...\",\"featured\":false,\"publishedAt\":\"2025-08-01T16:39:28.061Z\",\"updatedAt\":\"2025-08-01T19:21:45.491Z\",\"author\":{\"__typename\":\"User\",\"id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"username\":\"elewis\",\"deactivated\":false,\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"bio\":{\"html\":\"\u003cp\u003eCTO at Kochava, previously a software engineer at IBM. \u003c/p\u003e\\n\u003cp\u003eFounding Engineer for Vaunt and Hayride. \u003c/p\u003e\\n\u003cp\u003eI make grave mistakes all the time... everything seems to work out. Wasm, Wasm, Wasm...Wasm\u003c/p\u003e\\n\"},\"socialMediaLinks\":{\"website\":\"https://elewis.dev/\",\"github\":\"https://github.com/elewis787\",\"twitter\":\"https://twitter.com/elewis787\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/elewis787/\"}},\"coAuthors\":[],\"seo\":{\"title\":\"Composable Agents\",\"description\":\"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly\",\"shouldNotIndex\":false},\"coverImage\":{\"url\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg\",\"isPortrait\":false,\"attribution\":null,\"isAttributionHidden\":false,\"photographer\":null},\"responseCount\":0,\"reactionCount\":10,\"replyCount\":0,\"content\":{\"html\":\"\u003ch1 id=\\\"heading-overview\\\"\u003eOverview\u003c/h1\u003e\\n\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://blog.hayride.dev/sandboxing-ai\\\"\u003eIn our last post\u003c/a\u003e, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\u003c/p\u003e\\n\u003cp\u003eHayride leverages the \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003esecurity\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003epor\u003c/a\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/portability/\\\"\u003etability\u003c/a\u003e benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\u003c/p\u003e\\n\u003cp\u003eIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using \u003cstrong\u003eGolang\u003c/strong\u003e, with a sprinkle of \u003cstrong\u003eRust\u003c/strong\u003e, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\u003c/p\u003e\\n\u003cp\u003eIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\u003c/p\u003e\\n\u003cp\u003eHere are some resources to get you up to speed on WebAssembly:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/\\\"\u003ehttps://wasi.dev/\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://component-model.bytecodealliance.org/introduction.html\\\"\u003ehttps://component-model.bytecodealliance.org/introduction.html\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://docs.hayride.dev/platform/concepts/wasm\\\"\u003ehttps://docs.hayride.dev/platform/concepts/wasm\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eLet’s dive in!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-prerequisites\\\"\u003ePrerequisites\u003c/h2\u003e\\n\u003cp\u003eBefore we can start implementing our application, several tools are required. Of note, Hayride leverages \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/interfaces#wasi-02\\\"\u003eWASI Preview 2\u003c/a\u003e, which is gaining support across various languages.\u003c/p\u003e\\n\u003cp\u003eWe’ll use the following tools in this post:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases\\\"\u003eHayride\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go\\\"\u003eWit-bindgen-go\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wit-deps\\\"\u003eWit-deps\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac\\\"\u003eWac\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://go.dev/doc/install\\\"\u003eGo\u003c/a\u003e version 1.23.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://tinygo.org/\\\"\u003eTinyGo\u003c/a\u003e version 0.33.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://www.rust-lang.org/tools/install\\\"\u003eRust +nightly\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/cargo-component\\\"\u003eCargo component\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003ePlease refer to the tools’ installation guides to get started.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-installing-hayride\\\"\u003eInstalling Hayride\u003c/h3\u003e\\n\u003cp\u003eThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ecurl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\u003c/p\u003e\\n\u003cp\u003eWindows users can visit our releases page to download the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi\\\"\u003eMSI installer\u003c/a\u003e and use it to install Hayride.\u003c/p\u003e\\n\u003cp\u003eAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running \u003ccode\u003ehayride help\u003c/code\u003e from your terminal.\u003c/p\u003e\\n\u003cp\u003eNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-building-a-cli-agent\\\"\u003eBuilding a CLI Agent\u003c/h2\u003e\\n\u003cp\u003eHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\u003c/p\u003e\\n\u003cp\u003eAn \u003cstrong\u003einterface\u003c/strong\u003e describes a single-focused, composable contract through which components can interact with each other and with hosts.\u003c/p\u003e\\n\u003cp\u003eInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., \u003cstrong\u003eexport\u003c/strong\u003e) or whether external code must fulfill the interface for the component to call (i.e., \u003cstrong\u003eimport\u003c/strong\u003e).\u003c/p\u003e\\n\u003cp\u003eInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\u003c/p\u003e\\n\u003cp\u003eHere is an example of how Hayride defines an agent runner interface using WIT:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    invoke: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    invoke-stream: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, writer: borrow\u0026lt;output-stream\u0026gt;, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;_,\u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eThe runner interface is responsible for invoking an agent and supplying a prompt or message.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eRunners\u003c/strong\u003e define the agent loop as a function that describes how the agent executes.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAgents\u003c/strong\u003e are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\u003c/p\u003e\\n\u003cp\u003eOur agent interface in WIT is defined as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tools};\\n    use hayride:mcp/types@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    resource agent {\\n        constructor(name: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, instruction: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, format: format, graph: graph-execution-context-stream, tools: option\u0026lt;tools\u0026gt;, context: option\u0026lt;context\u0026gt;);\\n        name: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        instruction: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        capabilities: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        context: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        compute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        execute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(params: call-tool-params)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003ecall\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\u003c/p\u003e\\n\u003cp\u003eFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-defining-our-morph\\\"\u003eDefining Our Morph\u003c/h3\u003e\\n\u003cp\u003eHayride Morphs are the fundamental building blocks of applications. They can \u003cstrong\u003eimport\u003c/strong\u003e functions to access external capabilities and can also \u003cstrong\u003eexport\u003c/strong\u003e their capabilities to other morphs.\u003c/p\u003e\\n\u003cp\u003eThe term \u003cstrong\u003emorph\u003c/strong\u003e simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\u003c/p\u003e\\n\u003cp\u003eOur CLI Agent Morph can be described in WIT using \u003cstrong\u003eworlds\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\u003c/p\u003e\\n\u003cp\u003eConnecting up some or all of a component’s imports to other components’ matching exports is called \u003cstrong\u003ecomposition\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eGiven this, we can define our component world as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:example@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.1\u003c/span\u003e;\\n\\nworld cli {\\n    include hayride:wasip2/imports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    include hayride:wasip2/exports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/runner@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/model-repository@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-project-setup\\\"\u003eProject Setup\u003c/h3\u003e\\n\u003cp\u003eFirst, we create our project’s directory layout:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir hayride-example-agent\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use \u003cstrong\u003ego mod\u003c/strong\u003e to initialize our application and dependencies:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ego mod init\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a directory called wit:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eWe use the world defined above and copy it to a file in our wit directory:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch ./wit/world.wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using \u003cstrong\u003ewit-deps\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eWit-deps requires a \u003ccode\u003edeps.toml\u003c/code\u003e to track dependencies. We can add it to our wit directory using the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003eTouch ./wit/deps.toml\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003edeps.toml\u003c/code\u003e file, add the following dependencies:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-ini\\\"\u003e\u003cspan class=\\\"hljs-attr\\\"\u003ewasip2\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003eai\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003emcp\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eTo pull these dependencies into our project, we use a tool called \u003cstrong\u003ewit-deps.\u003c/strong\u003e\u003c/p\u003e\\n\u003cp\u003eFrom the project’s root, run the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ewit-deps update\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a \u003ccode\u003emain.go\u003c/code\u003e file and start implementing our CLI application:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch main.go\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-cli-application\\\"\u003eCLI Application\u003c/h3\u003e\\n\u003cp\u003eOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\u003c/p\u003e\\n\u003cp\u003eFirst, let’s start by creating the necessary objects using Hayride’s \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings\\\"\u003ebindings repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003emain.go\u003c/code\u003e file, add the following lines of code:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis code simply creates the various objects that our runner and agent require to execute:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eContext\u003c/strong\u003e: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTools\u003c/strong\u003e: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eFormat\u003c/strong\u003e: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eGraphExecutionCtxStream\u003c/strong\u003e: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-nn/releases\\\"\u003ewasi-nn\u003c/a\u003e to allow for streaming responses.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eNext, we add the code to read from \u003cstrong\u003eSTDIN\u003c/strong\u003e and create a \u003cstrong\u003eSTDOUT\u003c/strong\u003e writer.\u003c/p\u003e\\n\u003cp\u003eSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s \u003cstrong\u003eSTDIN/STDOUT\u003c/strong\u003e in our application.\u003c/p\u003e\\n\u003cp\u003eWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an \u003ccode\u003eio.Writer\u003c/code\u003e when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\u003c/p\u003e\\n\u003cp\u003eTo avoid this limitation, we have implemented a few WASI helpers in the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings/tree/main/go/wasi\\\"\u003ebindings repository\u003c/a\u003e. The main helper to leverage is our implementation of the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit\\\"\u003e\u003cstrong\u003ewasi-cli\u003c/strong\u003e\u003c/a\u003e interface.\u003c/p\u003e\\n\u003cp\u003eUsing our bindings, we can create an \u003ccode\u003eio.Writer\u003c/code\u003e that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003ewriter := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\nreader := bufio.NewReader(os.Stdin)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003efmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n    input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n    prompt := strings.TrimSpace(input)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n    }\\n\\n    msg := types.Message{\\n        Role: types.RoleUser,\\n        Content: cm.ToList([]types.MessageContent{\\n            types.NewMessageContent(types.Text(input)),\\n        }),\\n    }\\n\\n    err := runner.InvokeStream(msg, writer, a)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n        os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n    }\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe runner’s \u003cstrong\u003eInvokeStream\u003c/strong\u003e function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\u003c/p\u003e\\n\u003cp\u003eThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/roadmap?utm_source=chatgpt.com\\\"\u003ewasi roadmap\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full code looks like this:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n\\n    writer := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\n    reader := bufio.NewReader(os.Stdin)\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n        input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n        prompt := strings.TrimSpace(input)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n            \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n        }\\n\\n        msg := types.Message{\\n            Role: types.RoleUser,\\n            Content: cm.ToList([]types.MessageContent{\\n                types.NewMessageContent(types.Text(input)),\\n            }),\\n        }\\n\\n        err := runner.InvokeStream(msg, writer, a)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n            os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n        }\\n\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to build and deploy our agent onto Hayride!\u003c/p\u003e\\n\u003cp\u003eWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-build-composition-and-deployment\\\"\u003eBuild Composition and Deployment\u003c/h3\u003e\\n\u003cp\u003eTo compose our CLI with the existing Wasm components supplied by Hayride, we use \u003cstrong\u003eWAC,\u003c/strong\u003e a tool for composing WebAssembly Components together. The source code for these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full language guide for WAC can be found \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md\\\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eWe start by creating a \u003ccode\u003ecli.wac\u003c/code\u003e with the following content:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-bash\\\"\u003epackage hayride:example;\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e context = new hayride:inmemory@0.0.1 {...}; \\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e llama = new hayride:llama31@0.0.1 {...};\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e tools = new hayride:default-tools@0.0.1 {...};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003eexport\u003c/span\u003e cli...;\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\u003c/p\u003e\\n\u003cp\u003eIn the above file, we are using the following Hayride Morphs:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003ehayride:inmemory@0.0.1\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003ehayride:llama31@0.0.1\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003ehayride:default-tools@0.0.1\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003ehayride:default-agent@0.0.1\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003ehayride:default-runner@0.0.1\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\u003c/p\u003e\\n\u003cp\u003eHayride has built-in support for WAC files, and we can execute our composition with the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eOnce we have the \u003ccode\u003ecomposed-cli-agent.wasm\u003c/code\u003e file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to execute our morph:\u003cbr /\u003e\u003ccode\u003ehayride cast --package hayride:composed-cli-agent@0.0.1 -it\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis command launches our CLI:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK\\\" alt /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h2\u003e\\n\u003cp\u003eIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\u003c/p\u003e\\n\u003cp\u003eIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\u003c/p\u003e\\n\u003cp\u003eTo stay informed about future developments, follow us on \u003ca target=\\\"_blank\\\" href=\\\"https://x.com/HayrideDev\\\"\u003eX\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev\\\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\\n\",\"markdown\":\"# Overview\\n\\n[In our last post](https://blog.hayride.dev/sandboxing-ai), we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\n\\nHayride leverages the [security](https://webassembly.org/docs/security/) and [por](https://webassembly.org/docs/security/)[tability](https://webassembly.org/docs/portability/) benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\\n\\nIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using **Golang**, with a sprinkle of **Rust**, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\\n\\nIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\\n\\nHere are some resources to get you up to speed on WebAssembly:\\n\\n* [https://wasi.dev/](https://wasi.dev/)\\n    \\n* [https://component-model.bytecodealliance.org/introduction.html](https://component-model.bytecodealliance.org/introduction.html)\\n    \\n* [https://docs.hayride.dev/platform/concepts/wasm](https://docs.hayride.dev/platform/concepts/wasm)\\n    \\n\\nLet’s dive in!\\n\\n## Prerequisites\\n\\nBefore we can start implementing our application, several tools are required. Of note, Hayride leverages [WASI Preview 2](https://wasi.dev/interfaces#wasi-02), which is gaining support across various languages.\\n\\nWe’ll use the following tools in this post:\\n\\n* [Hayride](https://github.com/hayride-dev/releases)\\n    \\n* [Wit-bindgen-go](https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go)\\n    \\n* [Wit-deps](https://github.com/bytecodealliance/wit-deps)\\n    \\n* [Wac](https://github.com/bytecodealliance/wac)\\n    \\n* [Go](https://go.dev/doc/install) version 1.23.0+\\n    \\n* [TinyGo](https://tinygo.org/) version 0.33.0+\\n    \\n* [Rust +nightly](https://www.rust-lang.org/tools/install)\\n    \\n* [Cargo component](https://github.com/bytecodealliance/cargo-component)\\n    \\n\\nPlease refer to the tools’ installation guides to get started.\\n\\n### Installing Hayride\\n\\nThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\\n\\n`curl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash`\\n\\nThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\\n\\nWindows users can visit our releases page to download the [MSI installer](https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi) and use it to install Hayride.\\n\\nAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running `hayride help` from your terminal.\\n\\nNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\\n\\n## Building a CLI Agent\\n\\nHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\\n\\nAn **interface** describes a single-focused, composable contract through which components can interact with each other and with hosts.\\n\\nInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., **export**) or whether external code must fulfill the interface for the component to call (i.e., **import**).\\n\\nInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\\n\\nHere is an example of how Hayride defines an agent runner interface using WIT:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    invoke: func(message: message, agent: borrow\u003cagent\u003e) -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n    invoke-stream: func(message: message, writer: borrow\u003coutput-stream\u003e, agent: borrow\u003cagent\u003e) -\u003e result\u003c_,error\u003e;\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit))\\n\\nThe runner interface is responsible for invoking an agent and supplying a prompt or message.\\n\\n**Runners** define the agent loop as a function that describes how the agent executes.\\n\\n**Agents** are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\\n\\nOur agent interface in WIT is defined as follows:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@0.0.61.{tools};\\n    use hayride:mcp/types@0.0.61.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    resource agent {\\n        constructor(name: string, instruction: string, format: format, graph: graph-execution-context-stream, tools: option\u003ctools\u003e, context: option\u003ccontext\u003e);\\n        name: func() -\u003e string;\\n        instruction: func() -\u003e string;\\n        capabilities: func() -\u003e result\u003clist\u003ctool\u003e, error\u003e;\\n        context: func() -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n        compute: func(message: message) -\u003e result\u003cmessage, error\u003e;\\n        execute: func(params: call-tool-params) -\u003e result\u003ccall-tool-result, error\u003e;\\n    }\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit))\\n\\nFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\\n\\nFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\\n\\n### Defining Our Morph\\n\\nHayride Morphs are the fundamental building blocks of applications. They can **import** functions to access external capabilities and can also **export** their capabilities to other morphs.\\n\\nThe term **morph** simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\\n\\nOur CLI Agent Morph can be described in WIT using **worlds**.\\n\\nA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\\n\\nConnecting up some or all of a component’s imports to other components’ matching exports is called **composition**.\\n\\nGiven this, we can define our component world as follows:\\n\\n```go\\npackage hayride:example@0.0.1;\\n\\nworld cli {\\n    include hayride:wasip2/imports@0.0.61;\\n    include hayride:wasip2/exports@0.0.61;\\n    \\n    import hayride:ai/runner@0.0.61;\\n    import hayride:ai/model-repository@0.0.61;\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2))\\n\\nNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\\n\\n### Project Setup\\n\\nFirst, we create our project’s directory layout:\\n\\n`mkdir hayride-example-agent`\\n\\nSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use **go mod** to initialize our application and dependencies:\\n\\n`go mod init`\\n\\nNext, we create a directory called wit:\\n\\n`mkdir wit`\\n\\nWe use the world defined above and copy it to a file in our wit directory:\\n\\n`touch ./wit/world.wit`\\n\\nTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using **wit-deps**.\\n\\nWit-deps requires a `deps.toml` to track dependencies. We can add it to our wit directory using the following command:\\n\\n`Touch ./wit/deps.toml`\\n\\nIn the `deps.toml` file, add the following dependencies:\\n\\n```ini\\nwasip2 = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\\nai = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\\nmcp = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\\n```\\n\\nTo pull these dependencies into our project, we use a tool called **wit-deps.**\\n\\nFrom the project’s root, run the following command:\\n\\n`wit-deps update`\\n\\nNext, we create a `main.go` file and start implementing our CLI application:\\n\\n`touch main.go`\\n\\nNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\\n\\n### CLI Application\\n\\nOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\\n\\nFirst, let’s start by creating the necessary objects using Hayride’s [bindings repository](https://github.com/hayride-dev/bindings).\\n\\nIn the `main.go` file, add the following lines of code:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n}\\n```\\n\\nThis code simply creates the various objects that our runner and agent require to execute:\\n\\n* **Repository:** The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\\n    \\n* **Context**: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\\n    \\n* **Tools**: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\\n    \\n* **Format**: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\\n    \\n* **GraphExecutionCtxStream**: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of [wasi-nn](https://github.com/WebAssembly/wasi-nn/releases) to allow for streaming responses.\\n    \\n\\nNext, we add the code to read from **STDIN** and create a **STDOUT** writer.\\n\\nSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s **STDIN/STDOUT** in our application.\\n\\nWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an `io.Writer` when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\\n\\nTo avoid this limitation, we have implemented a few WASI helpers in the [bindings repository](https://github.com/hayride-dev/bindings/tree/main/go/wasi). The main helper to leverage is our implementation of the [**wasi-cli**](https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit) interface.\\n\\nUsing our bindings, we can create an `io.Writer` that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\\n\\n```go\\nwriter := cli.GetStdout(true)\\nreader := bufio.NewReader(os.Stdin)\\n```\\n\\nLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\\n\\n```go\\nfmt.Println(\\\"What can I help with?\\\")\\nfor {\\n\\tinput, _ := reader.ReadString('\\\\n')\\n\\tprompt := strings.TrimSpace(input)\\n\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\tbreak\\n\\t}\\n\\n\\tmsg := types.Message{\\n\\t\\tRole: types.RoleUser,\\n\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t}),\\n\\t}\\n\\n\\terr := runner.InvokeStream(msg, writer, a)\\n\\tif err != nil {\\n\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n\\n\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n}\\n```\\n\\nThe runner’s **InvokeStream** function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\\n\\nThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the [wasi roadmap](https://wasi.dev/roadmap?utm_source=chatgpt.com).\\n\\nThe full code looks like this:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n\\n\\twriter := cli.GetStdout(true)\\n\\treader := bufio.NewReader(os.Stdin)\\n\\n\\tfmt.Println(\\\"What can I help with?\\\")\\n\\tfor {\\n\\t\\tinput, _ := reader.ReadString('\\\\n')\\n\\t\\tprompt := strings.TrimSpace(input)\\n\\t\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tmsg := types.Message{\\n\\t\\t\\tRole: types.RoleUser,\\n\\t\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t\\t}),\\n\\t\\t}\\n\\n\\t\\terr := runner.InvokeStream(msg, writer, a)\\n\\t\\tif err != nil {\\n\\t\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\t\\tos.Exit(1)\\n\\t\\t}\\n\\n\\t\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n\\t}\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go))\\n\\nAll that’s left is to build and deploy our agent onto Hayride!\\n\\nWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\\n\\n### Build Composition and Deployment\\n\\nTo compose our CLI with the existing Wasm components supplied by Hayride, we use **WAC,** a tool for composing WebAssembly Components together. The source code for these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nThe full language guide for WAC can be found [here](https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md).\\n\\nWe start by creating a `cli.wac` with the following content:\\n\\n```bash\\npackage hayride:example;\\n\\nlet context = new hayride:inmemory@0.0.1 {...}; \\nlet llama = new hayride:llama31@0.0.1 {...};\\nlet tools = new hayride:default-tools@0.0.1 {...};\\n\\nlet agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\nlet runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\nlet cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\nexport cli...;\\n```\\n\\nThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\\n\\nIn the above file, we are using the following Hayride Morphs:\\n\\n* hayride:inmemory@0.0.1\\n    \\n* hayride:llama31@0.0.1\\n    \\n* hayride:default-tools@0.0.1\\n    \\n* hayride:default-agent@0.0.1\\n    \\n* hayride:default-runner@0.0.1\\n    \\n\\nUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\\n\\nHayride has built-in support for WAC files, and we can execute our composition with the following command:\\n\\n`hayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm`\\n\\nOnce we have the `composed-cli-agent.wasm` file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\\n\\n`hayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1`\\n\\nAll that’s left is to execute our morph:   \\n`hayride cast --package hayride:composed-cli-agent@0.0.1 -it`\\n\\nThis command launches our CLI:\\n\\n![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK align=\\\"left\\\")\\n\\n## Conclusion\\n\\nIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\\n\\nIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\\n\\nTo stay informed about future developments, follow us on [X](https://x.com/HayrideDev) and [GitHub](https://github.com/hayride-dev).\"},\"views\":494,\"preferences\":{\"pinnedToBlog\":false,\"disableComments\":true,\"stickCoverToBottom\":false,\"isDelisted\":false},\"readTimeInMinutes\":11,\"series\":null,\"tags\":[{\"id\":\"56744721958ef13879b94e1c\",\"slug\":\"golang\",\"name\":\"golang\"},{\"id\":\"56744722958ef13879b95043\",\"slug\":\"webassembly\",\"name\":\"WebAssembly\"},{\"id\":\"56744721958ef13879b9488e\",\"slug\":\"ai\",\"name\":\"AI\"},{\"id\":\"6347ba4bad721d4c5133e3c2\",\"slug\":\"ai-tools\",\"name\":\"#ai-tools\"},{\"id\":\"635ad52efe8087002dee4707\",\"slug\":\"llm\",\"name\":\"llm\"}],\"ogMetaData\":{\"image\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066340300/28af3dcf-9f58-4299-b182-9be5216337bc.jpeg\"},\"canonicalUrl\":null,\"hasLatexInPost\":false,\"audioUrls\":null,\"isFollowed\":null,\"bookmarked\":false,\"features\":{\"tableOfContents\":{\"isEnabled\":true,\"items\":[{\"__typename\":\"TableOfContentsItem\",\"id\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\",\"level\":1,\"slug\":\"overview\",\"title\":\"Overview\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\",\"level\":2,\"slug\":\"prerequisites\",\"title\":\"Prerequisites\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"7a129beb-fd1a-41e5-a602-388021ed3f6a\",\"level\":3,\"slug\":\"installing-hayride\",\"title\":\"Installing Hayride\",\"parentId\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\",\"level\":2,\"slug\":\"building-a-cli-agent\",\"title\":\"Building a CLI Agent\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"d97e814c-4f20-4902-8f53-0d70fa9999a3\",\"level\":3,\"slug\":\"defining-our-morph\",\"title\":\"Defining Our Morph\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"294da59e-c03c-4d11-9bad-251d1d8e5516\",\"level\":3,\"slug\":\"project-setup\",\"title\":\"Project Setup\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"b4ac9c3c-ee04-49f3-ba49-2467d4f0a542\",\"level\":3,\"slug\":\"cli-application\",\"title\":\"CLI Application\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"701498c3-5104-40f8-822e-2935909a0747\",\"level\":3,\"slug\":\"build-composition-and-deployment\",\"title\":\"Build Composition and Deployment\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"9292c17a-23da-4664-b4ec-c5983894fbf8\",\"level\":2,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}]},\"badges\":{\"isEnabled\":true,\"items\":[]}},\"isAutoPublishedFromRSS\":false,\"authenticatedUserLikes\":{\"edges\":[]},\"totalUserLikes\":{\"totalDocuments\":1},\"isShadowBanned\":false,\"isAskMeAnything\":false},\"redirectedPost\":null,\"staticPage\":null}","totalUsersWhoLikedArticle":1,"integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"gTagManagerID":null,"plausibleAnalyticsEnabled":null,"koalaPublicKey":null,"msClarityID":null,"domainURL":"blog.hayride.dev"},"rootLayout":{"legacyPublicationJSON":"{\"_id\":\"68541f2eb35e0480fa6966dc\",\"author\":{\"_id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"username\":\"elewis\"},\"badgePageEnabled\":true,\"description\":\"\",\"domain\":\"blog.hayride.dev\",\"domainStatus\":{\"ready\":true,\"certIssued\":true},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355712150/ce8b55fe-703f-427c-a478-676d75fb6530.png\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"publicMembersCount\":3,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png\",\"gaTrackingID\":\"\",\"gTagManagerID\":\"\",\"hasBadges\":false,\"headerColor\":\"\",\"hideMembersPage\":true,\"isTeam\":true,\"layout\":\"stacked\",\"membersPageEnabled\":false,\"menu\":[{\"_id\":\"686ecd07b6374d88e8285f60\",\"label\":\"docs\",\"type\":\"link\",\"url\":\"https://docs.hayride.dev/\"}],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":true,\"proTeamEnabled\":false,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1752092095732/dc6e4b98-d156-4a97-ab89-2329434b9d85.jpeg\",\"logo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png\",\"textSelectionSharerEnabled\":true,\"title\":\"Hayride\",\"urlPattern\":\"simple\",\"username\":\"hayride\",\"viewCountVisible\":true,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"\",\"github\":\"https://github.com/hayride-dev\",\"website\":\"https://hayride.dev\",\"hashnode\":\"\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"\",\"mastodon\":\"\",\"facebook\":\"\"},\"numPosts\":2,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"allowContributorEdits\":true,\"allowCrawlingByGPT\":false}","legacyPostJSON":"{\"_id\":\"688cedc0cc9d97047fda4fc7\",\"partOfPublication\":true,\"author\":{\"_id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"username\":\"elewis\",\"bio\":\"\u003cp\u003eCTO at Kochava, previously a software engineer at IBM. \u003c/p\u003e\\n\u003cp\u003eFounding Engineer for Vaunt and Hayride. \u003c/p\u003e\\n\u003cp\u003eI make grave mistakes all the time... everything seems to work out. Wasm, Wasm, Wasm...Wasm\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"https://elewis.dev/\",\"github\":\"https://github.com/elewis787\",\"twitter\":\"https://twitter.com/elewis787\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/elewis787/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"68541f2eb35e0480fa6966dc\",\"author\":{\"_id\":\"63f1a1c80e63a77a616fea30\",\"name\":\"Ethan Lewis\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg\",\"username\":\"elewis\"},\"badgePageEnabled\":true,\"description\":\"\",\"domain\":\"blog.hayride.dev\",\"domainStatus\":{\"ready\":true,\"certIssued\":true},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeEnabled\":false,\"darkModeLogo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355712150/ce8b55fe-703f-427c-a478-676d75fb6530.png\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"publicMembersCount\":3,\"displayTitle\":\"\",\"favicon\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png\",\"gaTrackingID\":\"\",\"gTagManagerID\":\"\",\"hasBadges\":false,\"headerColor\":\"\",\"hideMembersPage\":true,\"isTeam\":true,\"layout\":\"stacked\",\"membersPageEnabled\":false,\"menu\":[{\"_id\":\"686ecd07b6374d88e8285f60\",\"label\":\"docs\",\"type\":\"link\",\"url\":\"https://docs.hayride.dev/\"}],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":true,\"proTeamEnabled\":false,\"newsletterPageEnabled\":false,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1752092095732/dc6e4b98-d156-4a97-ab89-2329434b9d85.jpeg\",\"logo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png\",\"textSelectionSharerEnabled\":true,\"title\":\"Hayride\",\"urlPattern\":\"simple\",\"username\":\"hayride\",\"viewCountVisible\":true,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"\",\"github\":\"https://github.com/hayride-dev\",\"website\":\"https://hayride.dev\",\"hashnode\":\"\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"\",\"mastodon\":\"\",\"facebook\":\"\"},\"numPosts\":2,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"allowContributorEdits\":true,\"allowCrawlingByGPT\":false},\"tags\":[{\"_id\":\"56744721958ef13879b94e1c\",\"slug\":\"golang\",\"name\":\"golang\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b95043\",\"slug\":\"webassembly\",\"name\":\"WebAssembly\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744721958ef13879b9488e\",\"slug\":\"ai\",\"name\":\"AI\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"6347ba4bad721d4c5133e3c2\",\"slug\":\"ai-tools\",\"name\":\"#ai-tools\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"635ad52efe8087002dee4707\",\"slug\":\"llm\",\"name\":\"llm\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":0,\"replyCount\":0,\"contentMarkdown\":\"# Overview\\n\\n[In our last post](https://blog.hayride.dev/sandboxing-ai), we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\n\\nHayride leverages the [security](https://webassembly.org/docs/security/) and [por](https://webassembly.org/docs/security/)[tability](https://webassembly.org/docs/portability/) benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\\n\\nIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using **Golang**, with a sprinkle of **Rust**, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\\n\\nIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\\n\\nHere are some resources to get you up to speed on WebAssembly:\\n\\n* [https://wasi.dev/](https://wasi.dev/)\\n    \\n* [https://component-model.bytecodealliance.org/introduction.html](https://component-model.bytecodealliance.org/introduction.html)\\n    \\n* [https://docs.hayride.dev/platform/concepts/wasm](https://docs.hayride.dev/platform/concepts/wasm)\\n    \\n\\nLet’s dive in!\\n\\n## Prerequisites\\n\\nBefore we can start implementing our application, several tools are required. Of note, Hayride leverages [WASI Preview 2](https://wasi.dev/interfaces#wasi-02), which is gaining support across various languages.\\n\\nWe’ll use the following tools in this post:\\n\\n* [Hayride](https://github.com/hayride-dev/releases)\\n    \\n* [Wit-bindgen-go](https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go)\\n    \\n* [Wit-deps](https://github.com/bytecodealliance/wit-deps)\\n    \\n* [Wac](https://github.com/bytecodealliance/wac)\\n    \\n* [Go](https://go.dev/doc/install) version 1.23.0+\\n    \\n* [TinyGo](https://tinygo.org/) version 0.33.0+\\n    \\n* [Rust +nightly](https://www.rust-lang.org/tools/install)\\n    \\n* [Cargo component](https://github.com/bytecodealliance/cargo-component)\\n    \\n\\nPlease refer to the tools’ installation guides to get started.\\n\\n### Installing Hayride\\n\\nThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\\n\\n`curl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash`\\n\\nThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\\n\\nWindows users can visit our releases page to download the [MSI installer](https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi) and use it to install Hayride.\\n\\nAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running `hayride help` from your terminal.\\n\\nNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\\n\\n## Building a CLI Agent\\n\\nHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\\n\\nAn **interface** describes a single-focused, composable contract through which components can interact with each other and with hosts.\\n\\nInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., **export**) or whether external code must fulfill the interface for the component to call (i.e., **import**).\\n\\nInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\\n\\nHere is an example of how Hayride defines an agent runner interface using WIT:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    invoke: func(message: message, agent: borrow\u003cagent\u003e) -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n    invoke-stream: func(message: message, writer: borrow\u003coutput-stream\u003e, agent: borrow\u003cagent\u003e) -\u003e result\u003c_,error\u003e;\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit))\\n\\nThe runner interface is responsible for invoking an agent and supplying a prompt or message.\\n\\n**Runners** define the agent loop as a function that describes how the agent executes.\\n\\n**Agents** are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\\n\\nOur agent interface in WIT is defined as follows:\\n\\n```go\\npackage hayride:ai@0.0.61;\\n\\ninterface agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@0.0.61.{tools};\\n    use hayride:mcp/types@0.0.61.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@0.2.0.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: func() -\u003e error-code;\\n        data: func() -\u003e string;\\n    }\\n\\n    resource agent {\\n        constructor(name: string, instruction: string, format: format, graph: graph-execution-context-stream, tools: option\u003ctools\u003e, context: option\u003ccontext\u003e);\\n        name: func() -\u003e string;\\n        instruction: func() -\u003e string;\\n        capabilities: func() -\u003e result\u003clist\u003ctool\u003e, error\u003e;\\n        context: func() -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\\n        compute: func(message: message) -\u003e result\u003cmessage, error\u003e;\\n        execute: func(params: call-tool-params) -\u003e result\u003ccall-tool-result, error\u003e;\\n    }\\n}\\n```\\n\\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit))\\n\\nFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\\n\\nFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\\n\\n### Defining Our Morph\\n\\nHayride Morphs are the fundamental building blocks of applications. They can **import** functions to access external capabilities and can also **export** their capabilities to other morphs.\\n\\nThe term **morph** simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\\n\\nOur CLI Agent Morph can be described in WIT using **worlds**.\\n\\nA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\\n\\nConnecting up some or all of a component’s imports to other components’ matching exports is called **composition**.\\n\\nGiven this, we can define our component world as follows:\\n\\n```go\\npackage hayride:example@0.0.1;\\n\\nworld cli {\\n    include hayride:wasip2/imports@0.0.61;\\n    include hayride:wasip2/exports@0.0.61;\\n    \\n    import hayride:ai/runner@0.0.61;\\n    import hayride:ai/model-repository@0.0.61;\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2))\\n\\nNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\\n\\n### Project Setup\\n\\nFirst, we create our project’s directory layout:\\n\\n`mkdir hayride-example-agent`\\n\\nSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use **go mod** to initialize our application and dependencies:\\n\\n`go mod init`\\n\\nNext, we create a directory called wit:\\n\\n`mkdir wit`\\n\\nWe use the world defined above and copy it to a file in our wit directory:\\n\\n`touch ./wit/world.wit`\\n\\nTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using **wit-deps**.\\n\\nWit-deps requires a `deps.toml` to track dependencies. We can add it to our wit directory using the following command:\\n\\n`Touch ./wit/deps.toml`\\n\\nIn the `deps.toml` file, add the following dependencies:\\n\\n```ini\\nwasip2 = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\\nai = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\\nmcp = \\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\\n```\\n\\nTo pull these dependencies into our project, we use a tool called **wit-deps.**\\n\\nFrom the project’s root, run the following command:\\n\\n`wit-deps update`\\n\\nNext, we create a `main.go` file and start implementing our CLI application:\\n\\n`touch main.go`\\n\\nNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\\n\\n### CLI Application\\n\\nOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\\n\\nFirst, let’s start by creating the necessary objects using Hayride’s [bindings repository](https://github.com/hayride-dev/bindings).\\n\\nIn the `main.go` file, add the following lines of code:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n}\\n```\\n\\nThis code simply creates the various objects that our runner and agent require to execute:\\n\\n* **Repository:** The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\\n    \\n* **Context**: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\\n    \\n* **Tools**: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\\n    \\n* **Format**: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\\n    \\n* **GraphExecutionCtxStream**: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of [wasi-nn](https://github.com/WebAssembly/wasi-nn/releases) to allow for streaming responses.\\n    \\n\\nNext, we add the code to read from **STDIN** and create a **STDOUT** writer.\\n\\nSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s **STDIN/STDOUT** in our application.\\n\\nWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an `io.Writer` when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\\n\\nTo avoid this limitation, we have implemented a few WASI helpers in the [bindings repository](https://github.com/hayride-dev/bindings/tree/main/go/wasi). The main helper to leverage is our implementation of the [**wasi-cli**](https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit) interface.\\n\\nUsing our bindings, we can create an `io.Writer` that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\\n\\n```go\\nwriter := cli.GetStdout(true)\\nreader := bufio.NewReader(os.Stdin)\\n```\\n\\nLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\\n\\n```go\\nfmt.Println(\\\"What can I help with?\\\")\\nfor {\\n\\tinput, _ := reader.ReadString('\\\\n')\\n\\tprompt := strings.TrimSpace(input)\\n\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\tbreak\\n\\t}\\n\\n\\tmsg := types.Message{\\n\\t\\tRole: types.RoleUser,\\n\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t}),\\n\\t}\\n\\n\\terr := runner.InvokeStream(msg, writer, a)\\n\\tif err != nil {\\n\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n\\n\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n}\\n```\\n\\nThe runner’s **InvokeStream** function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\\n\\nThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the [wasi roadmap](https://wasi.dev/roadmap?utm_source=chatgpt.com).\\n\\nThe full code looks like this:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"log\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\\n\\t\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\\n\\t\\\"go.bytecodealliance.org/cm\\\"\\n)\\n\\nfunc main() {\\n\\trepo := repository.New()\\n\\tpath, err := repo.DownloadModel(\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\")\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to download model:\\\", err)\\n\\t}\\n\\n\\t// Initialize the context, tools, and model format\\n\\tctx, err := ctx.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create context:\\\", err)\\n\\t}\\n\\n\\ttools, err := tools.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create tools:\\\", err)\\n\\t}\\n\\n\\tformat, err := models.New()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create model format:\\\", err)\\n\\t}\\n\\n\\t// host provides a graph stream\\n\\tinferenceStream, err := graph.LoadByName(path)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to load graph:\\\", err)\\n\\t}\\n\\n\\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to initialize graph execution context stream:\\\", err)\\n\\t}\\n\\n\\ta, err := agents.New(\\n\\t\\tformat, graphExecutionCtxStream,\\n\\t\\tagents.WithName(\\\"Helpful Agent\\\"),\\n\\t\\tagents.WithInstruction(\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"),\\n\\t\\tagents.WithContext(ctx),\\n\\t\\tagents.WithTools(tools),\\n\\t)\\n\\tif err != nil {\\n\\t\\tlog.Fatal(\\\"failed to create agent:\\\", err)\\n\\t}\\n\\n\\trunner := runner.New()\\n\\n\\twriter := cli.GetStdout(true)\\n\\treader := bufio.NewReader(os.Stdin)\\n\\n\\tfmt.Println(\\\"What can I help with?\\\")\\n\\tfor {\\n\\t\\tinput, _ := reader.ReadString('\\\\n')\\n\\t\\tprompt := strings.TrimSpace(input)\\n\\t\\tif strings.ToLower(prompt) == \\\"exit\\\" {\\n\\t\\t\\tfmt.Println(\\\"Goodbye!\\\")\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tmsg := types.Message{\\n\\t\\t\\tRole: types.RoleUser,\\n\\t\\t\\tContent: cm.ToList([]types.MessageContent{\\n\\t\\t\\t\\ttypes.NewMessageContent(types.Text(input)),\\n\\t\\t\\t}),\\n\\t\\t}\\n\\n\\t\\terr := runner.InvokeStream(msg, writer, a)\\n\\t\\tif err != nil {\\n\\t\\t\\tfmt.Println(\\\"error invoking agent:\\\", err)\\n\\t\\t\\tos.Exit(1)\\n\\t\\t}\\n\\n\\t\\tfmt.Println(\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\")\\n\\t}\\n}\\n```\\n\\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go))\\n\\nAll that’s left is to build and deploy our agent onto Hayride!\\n\\nWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\\n\\n### Build Composition and Deployment\\n\\nTo compose our CLI with the existing Wasm components supplied by Hayride, we use **WAC,** a tool for composing WebAssembly Components together. The source code for these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\\n\\nThe full language guide for WAC can be found [here](https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md).\\n\\nWe start by creating a `cli.wac` with the following content:\\n\\n```bash\\npackage hayride:example;\\n\\nlet context = new hayride:inmemory@0.0.1 {...}; \\nlet llama = new hayride:llama31@0.0.1 {...};\\nlet tools = new hayride:default-tools@0.0.1 {...};\\n\\nlet agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\nlet runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\nlet cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\nexport cli...;\\n```\\n\\nThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\\n\\nIn the above file, we are using the following Hayride Morphs:\\n\\n* hayride:inmemory@0.0.1\\n    \\n* hayride:llama31@0.0.1\\n    \\n* hayride:default-tools@0.0.1\\n    \\n* hayride:default-agent@0.0.1\\n    \\n* hayride:default-runner@0.0.1\\n    \\n\\nUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\\n\\nHayride has built-in support for WAC files, and we can execute our composition with the following command:\\n\\n`hayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm`\\n\\nOnce we have the `composed-cli-agent.wasm` file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\\n\\n`hayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1`\\n\\nAll that’s left is to execute our morph:   \\n`hayride cast --package hayride:composed-cli-agent@0.0.1 -it`\\n\\nThis command launches our CLI:\\n\\n![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK align=\\\"left\\\")\\n\\n## Conclusion\\n\\nIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\\n\\nIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\\n\\nTo stay informed about future developments, follow us on [X](https://x.com/HayrideDev) and [GitHub](https://github.com/hayride-dev).\",\"content\":\"\u003ch1 id=\\\"heading-overview\\\"\u003eOverview\u003c/h1\u003e\\n\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://blog.hayride.dev/sandboxing-ai\\\"\u003eIn our last post\u003c/a\u003e, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\u003c/p\u003e\\n\u003cp\u003eHayride leverages the \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003esecurity\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/security/\\\"\u003epor\u003c/a\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://webassembly.org/docs/portability/\\\"\u003etability\u003c/a\u003e benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\u003c/p\u003e\\n\u003cp\u003eIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using \u003cstrong\u003eGolang\u003c/strong\u003e, with a sprinkle of \u003cstrong\u003eRust\u003c/strong\u003e, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\u003c/p\u003e\\n\u003cp\u003eIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\u003c/p\u003e\\n\u003cp\u003eHere are some resources to get you up to speed on WebAssembly:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/\\\"\u003ehttps://wasi.dev/\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://component-model.bytecodealliance.org/introduction.html\\\"\u003ehttps://component-model.bytecodealliance.org/introduction.html\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://docs.hayride.dev/platform/concepts/wasm\\\"\u003ehttps://docs.hayride.dev/platform/concepts/wasm\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eLet’s dive in!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-prerequisites\\\"\u003ePrerequisites\u003c/h2\u003e\\n\u003cp\u003eBefore we can start implementing our application, several tools are required. Of note, Hayride leverages \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/interfaces#wasi-02\\\"\u003eWASI Preview 2\u003c/a\u003e, which is gaining support across various languages.\u003c/p\u003e\\n\u003cp\u003eWe’ll use the following tools in this post:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases\\\"\u003eHayride\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go\\\"\u003eWit-bindgen-go\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wit-deps\\\"\u003eWit-deps\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac\\\"\u003eWac\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://go.dev/doc/install\\\"\u003eGo\u003c/a\u003e version 1.23.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://tinygo.org/\\\"\u003eTinyGo\u003c/a\u003e version 0.33.0+\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://www.rust-lang.org/tools/install\\\"\u003eRust +nightly\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/cargo-component\\\"\u003eCargo component\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003ePlease refer to the tools’ installation guides to get started.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-installing-hayride\\\"\u003eInstalling Hayride\u003c/h3\u003e\\n\u003cp\u003eThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ecurl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\u003c/p\u003e\\n\u003cp\u003eWindows users can visit our releases page to download the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi\\\"\u003eMSI installer\u003c/a\u003e and use it to install Hayride.\u003c/p\u003e\\n\u003cp\u003eAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running \u003ccode\u003ehayride help\u003c/code\u003e from your terminal.\u003c/p\u003e\\n\u003cp\u003eNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\u003c/p\u003e\\n\u003ch2 id=\\\"heading-building-a-cli-agent\\\"\u003eBuilding a CLI Agent\u003c/h2\u003e\\n\u003cp\u003eHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\u003c/p\u003e\\n\u003cp\u003eAn \u003cstrong\u003einterface\u003c/strong\u003e describes a single-focused, composable contract through which components can interact with each other and with hosts.\u003c/p\u003e\\n\u003cp\u003eInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., \u003cstrong\u003eexport\u003c/strong\u003e) or whether external code must fulfill the interface for the component to call (i.e., \u003cstrong\u003eimport\u003c/strong\u003e).\u003c/p\u003e\\n\u003cp\u003eInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\u003c/p\u003e\\n\u003cp\u003eHere is an example of how Hayride defines an agent runner interface using WIT:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e runner {\\n    use types.{message};\\n    use agents.{agent};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        invoke-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    invoke: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    invoke-stream: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message, writer: borrow\u0026lt;output-stream\u0026gt;, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;_,\u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eThe runner interface is responsible for invoking an agent and supplying a prompt or message.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eRunners\u003c/strong\u003e define the agent loop as a function that describes how the agent executes.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAgents\u003c/strong\u003e are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\u003c/p\u003e\\n\u003cp\u003eOur agent interface in WIT is defined as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e agents {\\n    use types.{message};\\n    use context.{context};\\n    use model.{format};\\n    use hayride:mcp/tools@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tools};\\n    use hayride:mcp/types@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e.{tool, call-tool-params, call-tool-result};\\n    use graph-stream.{graph-stream};\\n    use inference-stream.{graph-execution-context-stream};\\n    use wasi:io/streams@\u003cspan class=\\\"hljs-number\\\"\u003e0.2\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.0\u003c/span\u003e.{output-stream};\\n\\n    enum error-code {\\n        capabilities-error,\\n        context-error,\\n        compute-error,\\n        execute-error,\\n        unknown\\n    }\\n\\n    resource error {\\n        code: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\\n        data: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n    }\\n\\n    resource agent {\\n        constructor(name: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, instruction: \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, format: format, graph: graph-execution-context-stream, tools: option\u0026lt;tools\u0026gt;, context: option\u0026lt;context\u0026gt;);\\n        name: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        instruction: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003estring\u003c/span\u003e;\u003c/span\u003e\\n        capabilities: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        context: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        compute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(message: message)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003emessage\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n        execute: \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(params: call-tool-params)\u003c/span\u003e -\u0026gt; \u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\\\"hljs-title\\\"\u003ecall\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003etool\u003c/span\u003e-\u003cspan class=\\\"hljs-title\\\"\u003eresult\u003c/span\u003e, \u003cspan class=\\\"hljs-title\\\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\\\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\u003c/p\u003e\\n\u003cp\u003eFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-defining-our-morph\\\"\u003eDefining Our Morph\u003c/h3\u003e\\n\u003cp\u003eHayride Morphs are the fundamental building blocks of applications. They can \u003cstrong\u003eimport\u003c/strong\u003e functions to access external capabilities and can also \u003cstrong\u003eexport\u003c/strong\u003e their capabilities to other morphs.\u003c/p\u003e\\n\u003cp\u003eThe term \u003cstrong\u003emorph\u003c/strong\u003e simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\u003c/p\u003e\\n\u003cp\u003eOur CLI Agent Morph can be described in WIT using \u003cstrong\u003eworlds\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\u003c/p\u003e\\n\u003cp\u003eConnecting up some or all of a component’s imports to other components’ matching exports is called \u003cstrong\u003ecomposition\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eGiven this, we can define our component world as follows:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e hayride:example@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.1\u003c/span\u003e;\\n\\nworld cli {\\n    include hayride:wasip2/imports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    include hayride:wasip2/exports@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/runner@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e hayride:ai/model-repository@\u003cspan class=\\\"hljs-number\\\"\u003e0.0\u003c/span\u003e\u003cspan class=\\\"hljs-number\\\"\u003e.61\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-project-setup\\\"\u003eProject Setup\u003c/h3\u003e\\n\u003cp\u003eFirst, we create our project’s directory layout:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir hayride-example-agent\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use \u003cstrong\u003ego mod\u003c/strong\u003e to initialize our application and dependencies:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ego mod init\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a directory called wit:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003emkdir wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eWe use the world defined above and copy it to a file in our wit directory:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch ./wit/world.wit\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using \u003cstrong\u003ewit-deps\u003c/strong\u003e.\u003c/p\u003e\\n\u003cp\u003eWit-deps requires a \u003ccode\u003edeps.toml\u003c/code\u003e to track dependencies. We can add it to our wit directory using the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003eTouch ./wit/deps.toml\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003edeps.toml\u003c/code\u003e file, add the following dependencies:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-ini\\\"\u003e\u003cspan class=\\\"hljs-attr\\\"\u003ewasip2\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003eai\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003cspan class=\\\"hljs-attr\\\"\u003emcp\u003c/span\u003e = \u003cspan class=\\\"hljs-string\\\"\u003e\\\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\\\"\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eTo pull these dependencies into our project, we use a tool called \u003cstrong\u003ewit-deps.\u003c/strong\u003e\u003c/p\u003e\\n\u003cp\u003eFrom the project’s root, run the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ewit-deps update\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNext, we create a \u003ccode\u003emain.go\u003c/code\u003e file and start implementing our CLI application:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003etouch main.go\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-cli-application\\\"\u003eCLI Application\u003c/h3\u003e\\n\u003cp\u003eOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\u003c/p\u003e\\n\u003cp\u003eFirst, let’s start by creating the necessary objects using Hayride’s \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings\\\"\u003ebindings repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eIn the \u003ccode\u003emain.go\u003c/code\u003e file, add the following lines of code:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis code simply creates the various objects that our runner and agent require to execute:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eContext\u003c/strong\u003e: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTools\u003c/strong\u003e: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eFormat\u003c/strong\u003e: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eGraphExecutionCtxStream\u003c/strong\u003e: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-nn/releases\\\"\u003ewasi-nn\u003c/a\u003e to allow for streaming responses.\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eNext, we add the code to read from \u003cstrong\u003eSTDIN\u003c/strong\u003e and create a \u003cstrong\u003eSTDOUT\u003c/strong\u003e writer.\u003c/p\u003e\\n\u003cp\u003eSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s \u003cstrong\u003eSTDIN/STDOUT\u003c/strong\u003e in our application.\u003c/p\u003e\\n\u003cp\u003eWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an \u003ccode\u003eio.Writer\u003c/code\u003e when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\u003c/p\u003e\\n\u003cp\u003eTo avoid this limitation, we have implemented a few WASI helpers in the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/bindings/tree/main/go/wasi\\\"\u003ebindings repository\u003c/a\u003e. The main helper to leverage is our implementation of the \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit\\\"\u003e\u003cstrong\u003ewasi-cli\u003c/strong\u003e\u003c/a\u003e interface.\u003c/p\u003e\\n\u003cp\u003eUsing our bindings, we can create an \u003ccode\u003eio.Writer\u003c/code\u003e that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003ewriter := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\nreader := bufio.NewReader(os.Stdin)\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003efmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n\u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n    input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n    prompt := strings.TrimSpace(input)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n    }\\n\\n    msg := types.Message{\\n        Role: types.RoleUser,\\n        Content: cm.ToList([]types.MessageContent{\\n            types.NewMessageContent(types.Text(input)),\\n        }),\\n    }\\n\\n    err := runner.InvokeStream(msg, writer, a)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n        os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n    }\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe runner’s \u003cstrong\u003eInvokeStream\u003c/strong\u003e function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\u003c/p\u003e\\n\u003cp\u003eThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the \u003ca target=\\\"_blank\\\" href=\\\"https://wasi.dev/roadmap?utm_source=chatgpt.com\\\"\u003ewasi roadmap\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full code looks like this:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-go\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"bufio\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"fmt\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"log\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"os\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"strings\\\"\u003c/span\u003e\\n\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/agents\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/graph\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/ai/runner\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/hayride/types\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"github.com/hayride-dev/bindings/go/wasi/cli\\\"\u003c/span\u003e\\n    \u003cspan class=\\\"hljs-string\\\"\u003e\\\"go.bytecodealliance.org/cm\\\"\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n    repo := repository.New()\\n    path, err := repo.DownloadModel(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to download model:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\\n    ctx, err := ctx.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create context:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    tools, err := tools.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create tools:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    format, err := models.New()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create model format:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    \u003cspan class=\\\"hljs-comment\\\"\u003e// host provides a graph stream\u003c/span\u003e\\n    inferenceStream, err := graph.LoadByName(path)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to load graph:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to initialize graph execution context stream:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    a, err := agents.New(\\n        format, graphExecutionCtxStream,\\n        agents.WithName(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Helpful Agent\\\"\u003c/span\u003e),\\n        agents.WithInstruction(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"You are a helpful assistant. Answer the user's questions to the best of your ability.\\\"\u003c/span\u003e),\\n        agents.WithContext(ctx),\\n        agents.WithTools(tools),\\n    )\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n        log.Fatal(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"failed to create agent:\\\"\u003c/span\u003e, err)\\n    }\\n\\n    runner := runner.New()\\n\\n    writer := cli.GetStdout(\u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e)\\n    reader := bufio.NewReader(os.Stdin)\\n\\n    fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"What can I help with?\\\"\u003c/span\u003e)\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e {\\n        input, _ := reader.ReadString(\u003cspan class=\\\"hljs-string\\\"\u003e'\\\\n'\u003c/span\u003e)\\n        prompt := strings.TrimSpace(input)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\\\"hljs-string\\\"\u003e\\\"exit\\\"\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"Goodbye!\\\"\u003c/span\u003e)\\n            \u003cspan class=\\\"hljs-keyword\\\"\u003ebreak\u003c/span\u003e\\n        }\\n\\n        msg := types.Message{\\n            Role: types.RoleUser,\\n            Content: cm.ToList([]types.MessageContent{\\n                types.NewMessageContent(types.Text(input)),\\n            }),\\n        }\\n\\n        err := runner.InvokeStream(msg, writer, a)\\n        \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e err != \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n            fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"error invoking agent:\\\"\u003c/span\u003e, err)\\n            os.Exit(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e)\\n        }\\n\\n        fmt.Println(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"\\\\nWhat else can I help with? (type 'exit' to quit)\\\"\u003c/span\u003e)\\n    }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e(\u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\\\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\u003c/a\u003e)\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to build and deploy our agent onto Hayride!\u003c/p\u003e\\n\u003cp\u003eWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-build-composition-and-deployment\\\"\u003eBuild Composition and Deployment\u003c/h3\u003e\\n\u003cp\u003eTo compose our CLI with the existing Wasm components supplied by Hayride, we use \u003cstrong\u003eWAC,\u003c/strong\u003e a tool for composing WebAssembly Components together. The source code for these components can be found in our \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev/morphs/tree/main/components\\\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThe full language guide for WAC can be found \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md\\\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eWe start by creating a \u003ccode\u003ecli.wac\u003c/code\u003e with the following content:\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"lang-bash\\\"\u003epackage hayride:example;\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e context = new hayride:inmemory@0.0.1 {...}; \\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e llama = new hayride:llama31@0.0.1 {...};\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e tools = new hayride:default-tools@0.0.1 {...};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e agent = new hayride:default-agent@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e runner = new hayride:default-runner@0.0.1 {\\n  agents: agent.agents,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003elet\u003c/span\u003e cli = new hayride:cli@0.0.1 {\\n  context: context.context,\\n  model: llama.model,\\n  tools: tools.tools,\\n  agents: agent.agents,\\n  runner: runner.runner,\\n  ...\\n};\\n\\n\u003cspan class=\\\"hljs-built_in\\\"\u003eexport\u003c/span\u003e cli...;\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\u003c/p\u003e\\n\u003cp\u003eIn the above file, we are using the following Hayride Morphs:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:inmemory@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:inmemory@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:llama31@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:llama31@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-tools@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-tools@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-agent@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-agent@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\u003cp\u003e\u003ca href=\\\"hayride:default-runner@0.0.1\\\" class=\\\"autolinkedURL autolinkedURL-url\\\" target=\\\"_blank\\\"\u003ehayride:default-runner@0.0.1\u003c/a\u003e\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\u003c/p\u003e\\n\u003cp\u003eHayride has built-in support for WAC files, and we can execute our composition with the following command:\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eOnce we have the \u003ccode\u003ecomposed-cli-agent.wasm\u003c/code\u003e file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\u003c/p\u003e\\n\u003cp\u003e\u003ccode\u003ehayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eAll that’s left is to execute our morph:\u003cbr /\u003e\u003ccode\u003ehayride cast --package hayride:composed-cli-agent@0.0.1 -it\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003eThis command launches our CLI:\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK\\\" alt /\u003e\u003c/p\u003e\\n\u003ch2 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h2\u003e\\n\u003cp\u003eIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\u003c/p\u003e\\n\u003cp\u003eIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\u003c/p\u003e\\n\u003cp\u003eTo stay informed about future developments, follow us on \u003ca target=\\\"_blank\\\" href=\\\"https://x.com/HayrideDev\\\"\u003eX\u003c/a\u003e and \u003ca target=\\\"_blank\\\" href=\\\"https://github.com/hayride-dev\\\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\\n\",\"cuid\":\"cmdt1trnh000o02l83zqf2foo\",\"views\":494,\"title\":\"Composable Agents\",\"slug\":\"composable-agents\",\"dateAdded\":\"2025-08-01T16:39:28.061Z\",\"dateUpdated\":\"2025-08-01T19:21:45.491Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"Overview\\nIn our last post, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\\nHayride leverages the security and portability benefits offered by WebAssembly, making it an id...\",\"isFollowing\":false,\"totalReactions\":10,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":11,\"sB\":false,\"isAMA\":false,\"subtitle\":\"It’s morphing time!\",\"isPartOfSeries\":false,\"hasTags\":true,\"ogImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066340300/28af3dcf-9f58-4299-b182-9be5216337bc.jpeg\",\"metaTitle\":\"Composable Agents\",\"metaDescription\":\"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":false,\"hasLatex\":false,\"stickCoverToBottom\":false,\"hideBadges\":false,\"badges\":[],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":true,\"enableToc\":true,\"toc\":[[{\"id\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\",\"level\":1,\"slug\":\"overview\",\"title\":\"Overview\",\"parentId\":null}],[{\"id\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\",\"level\":2,\"slug\":\"prerequisites\",\"title\":\"Prerequisites\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}],[{\"id\":\"7a129beb-fd1a-41e5-a602-388021ed3f6a\",\"level\":3,\"slug\":\"installing-hayride\",\"title\":\"Installing Hayride\",\"parentId\":\"851dff37-fd27-41cd-b828-eb0ba56a7146\"}],[{\"id\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\",\"level\":2,\"slug\":\"building-a-cli-agent\",\"title\":\"Building a CLI Agent\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}],[{\"id\":\"d97e814c-4f20-4902-8f53-0d70fa9999a3\",\"level\":3,\"slug\":\"defining-our-morph\",\"title\":\"Defining Our Morph\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"294da59e-c03c-4d11-9bad-251d1d8e5516\",\"level\":3,\"slug\":\"project-setup\",\"title\":\"Project Setup\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"b4ac9c3c-ee04-49f3-ba49-2467d4f0a542\",\"level\":3,\"slug\":\"cli-application\",\"title\":\"CLI Application\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"701498c3-5104-40f8-822e-2935909a0747\",\"level\":3,\"slug\":\"build-composition-and-deployment\",\"title\":\"Build Composition and Deployment\",\"parentId\":\"5d1ec457-096e-4248-8576-4d29e46d34d9\"}],[{\"id\":\"9292c17a-23da-4664-b4ec-c5983894fbf8\",\"level\":2,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":\"c62e2bf4-0455-461a-8816-5e66e4315fe5\"}]],\"noIndex\":false}","legacySeriesJSON":null,"headProps":{"title":"Composable Agents","description":"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly","author":{"name":"Ethan Lewis","username":"elewis"},"links":[{"rel":"canonical","href":"https://blog.hayride.dev/composable-agents"}],"pageType":"article","bannerType":"large","ogSiteName":"Hayride","url":"https://blog.hayride.dev/composable-agents","ogImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1754066340300%2F28af3dcf-9f58-4299-b182-9be5216337bc.jpeg%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1754066340300%2F28af3dcf-9f58-4299-b182-9be5216337bc.jpeg%3Fw%3D1200%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterHandle":"@elewis787","monetization":null,"style":{},"customHeadItems":{"customFavicon":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png?auto=compress,format\u0026format=webp\u0026fm=png","customTheme":null,"customMeta":null},"hljs":true},"isDarkTheme":false,"headerColor":null,"isBadge":null,"isRecommendations":null,"isHome":null,"currentMenuId":null,"hnmcMode":false,"postCUID":"cmdt1trnh000o02l83zqf2foo","seoSchema":{"@context":"https://schema.org","@type":"NewsArticle","url":"https://blog.hayride.dev/composable-agents","mainEntityOfPage":"https://blog.hayride.dev/composable-agents","headline":"Composable Agents","description":"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly","datePublished":"2025-08-01T16:39:28.061Z","dateModified":"2025-08-01T19:21:45.491Z","isAccessibleForFree":true,"author":{"@type":"Person","name":"Ethan Lewis","url":"https://hashnode.com/@elewis","sameAs":"https://twitter.com/elewis787"},"publisher":{"@type":"Organization","name":"Hayride","url":"https://blog.hayride.dev","logo":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png"},"image":{"@type":"ImageObject","url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg"}},"publication":{"__typename":"Publication","id":"68541f2eb35e0480fa6966dc","url":"https://blog.hayride.dev","canonicalURL":"https://blog.hayride.dev","urlPattern":"SIMPLE","title":"Hayride","displayTitle":null,"hasBadges":false,"descriptionSEO":null,"publicMembers":{"totalDocuments":3},"about":null,"features":{"proTeam":{"isEnabled":false},"newsletter":{"isEnabled":true},"viewCount":{"isEnabled":true},"readTime":{"isEnabled":true},"textSelectionSharer":{"isEnabled":true},"customCSS":{"isEnabled":false,"published":null,"draft":null},"gptBotCrawling":{"__typename":"GPTBotCrawlingFeature","isEnabled":false}},"metaTags":null,"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1752092095732/dc6e4b98-d156-4a97-ab89-2329434b9d85.jpeg"},"author":{"__typename":"User","id":"63f1a1c80e63a77a616fea30","name":"Ethan Lewis","username":"elewis","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg"},"preferences":{"__typename":"Preferences","logo":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355691977/3b6bb668-ae6b-4cad-a08f-c38c424c56bd.png","darkMode":{"__typename":"DarkModePreferences","logo":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355712150/ce8b55fe-703f-427c-a478-676d75fb6530.png","enabled":false},"navbarItems":[{"__typename":"PublicationNavbarItem","id":"686ecd07b6374d88e8285f60","label":"docs","url":"https://docs.hayride.dev/","type":"link","series":null,"page":null}],"enabledPages":{"__typename":"PagesPreferences","badges":false,"newsletter":true,"members":false},"layout":"stacked","disableFooterBranding":false,"isSubscriptionModalDisabled":false},"favicon":"https://cdn.hashnode.com/res/hashnode/image/upload/v1750355727794/16f10cdd-322b-40b4-a40c-7093cbee8747.png","headerColor":null,"integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"gTagManagerID":null,"plausibleAnalyticsEnabled":null,"koalaPublicKey":null,"msClarityID":null},"imprintV2":null,"postsCount":{"totalDocuments":2},"isTeam":true,"links":{"twitter":null,"instagram":null,"github":"https://github.com/hayride-dev","website":"https://hayride.dev","hashnode":null,"youtube":null,"dailydev":null,"linkedin":null,"mastodon":null,"facebook":null,"bluesky":null},"domainInfo":{"__typename":"DomainInfo","hashnodeSubdomain":"hayride","domain":{"__typename":"DomainStatus","host":"blog.hayride.dev","ready":true},"wwwPrefixedDomain":null},"redirectionRules":[],"totalRecommendedPublications":0,"sponsorship":{"content":null,"stripe":null},"allowContributorEdits":true,"rssImport":null,"post":{"id":"688cedc0cc9d97047fda4fc7","cuid":"cmdt1trnh000o02l83zqf2foo","title":"Composable Agents","subtitle":"It’s morphing time!","slug":"composable-agents","brief":"Overview\nIn our last post, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\nHayride leverages the security and portability benefits offered by WebAssembly, making it an id...","featured":false,"publishedAt":"2025-08-01T16:39:28.061Z","updatedAt":"2025-08-01T19:21:45.491Z","author":{"__typename":"User","id":"63f1a1c80e63a77a616fea30","name":"Ethan Lewis","username":"elewis","deactivated":false,"profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680826414591/loaustnmw.jpeg","bio":{"html":"\u003cp\u003eCTO at Kochava, previously a software engineer at IBM. \u003c/p\u003e\n\u003cp\u003eFounding Engineer for Vaunt and Hayride. \u003c/p\u003e\n\u003cp\u003eI make grave mistakes all the time... everything seems to work out. Wasm, Wasm, Wasm...Wasm\u003c/p\u003e\n"},"socialMediaLinks":{"website":"https://elewis.dev/","github":"https://github.com/elewis787","twitter":"https://twitter.com/elewis787","facebook":"","stackoverflow":"","linkedin":"https://www.linkedin.com/in/elewis787/"}},"coAuthors":[],"seo":{"title":"Composable Agents","description":"Learn how to use Hayride to build composable agents using Go, Rust, and WebAssembly","shouldNotIndex":false},"coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066285929/a55de9b4-aa86-400b-91bd-fb0fbe25516e.jpeg","isPortrait":false,"attribution":null,"isAttributionHidden":false,"photographer":null},"responseCount":0,"reactionCount":10,"replyCount":0,"content":{"html":"\u003ch1 id=\"heading-overview\"\u003eOverview\u003c/h1\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://blog.hayride.dev/sandboxing-ai\"\u003eIn our last post\u003c/a\u003e, we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\u003c/p\u003e\n\u003cp\u003eHayride leverages the \u003ca target=\"_blank\" href=\"https://webassembly.org/docs/security/\"\u003esecurity\u003c/a\u003e and \u003ca target=\"_blank\" href=\"https://webassembly.org/docs/security/\"\u003epor\u003c/a\u003e\u003ca target=\"_blank\" href=\"https://webassembly.org/docs/portability/\"\u003etability\u003c/a\u003e benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\u003c/p\u003e\n\u003cp\u003eIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using \u003cstrong\u003eGolang\u003c/strong\u003e, with a sprinkle of \u003cstrong\u003eRust\u003c/strong\u003e, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\u003c/p\u003e\n\u003cp\u003eIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\u003c/p\u003e\n\u003cp\u003eHere are some resources to get you up to speed on WebAssembly:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://wasi.dev/\"\u003ehttps://wasi.dev/\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://component-model.bytecodealliance.org/introduction.html\"\u003ehttps://component-model.bytecodealliance.org/introduction.html\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://docs.hayride.dev/platform/concepts/wasm\"\u003ehttps://docs.hayride.dev/platform/concepts/wasm\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s dive in!\u003c/p\u003e\n\u003ch2 id=\"heading-prerequisites\"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eBefore we can start implementing our application, several tools are required. Of note, Hayride leverages \u003ca target=\"_blank\" href=\"https://wasi.dev/interfaces#wasi-02\"\u003eWASI Preview 2\u003c/a\u003e, which is gaining support across various languages.\u003c/p\u003e\n\u003cp\u003eWe’ll use the following tools in this post:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/releases\"\u003eHayride\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go\"\u003eWit-bindgen-go\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://github.com/bytecodealliance/wit-deps\"\u003eWit-deps\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://github.com/bytecodealliance/wac\"\u003eWac\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://go.dev/doc/install\"\u003eGo\u003c/a\u003e version 1.23.0+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://tinygo.org/\"\u003eTinyGo\u003c/a\u003e version 0.33.0+\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://www.rust-lang.org/tools/install\"\u003eRust +nightly\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://github.com/bytecodealliance/cargo-component\"\u003eCargo component\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePlease refer to the tools’ installation guides to get started.\u003c/p\u003e\n\u003ch3 id=\"heading-installing-hayride\"\u003eInstalling Hayride\u003c/h3\u003e\n\u003cp\u003eThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecurl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\u003c/p\u003e\n\u003cp\u003eWindows users can visit our releases page to download the \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi\"\u003eMSI installer\u003c/a\u003e and use it to install Hayride.\u003c/p\u003e\n\u003cp\u003eAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running \u003ccode\u003ehayride help\u003c/code\u003e from your terminal.\u003c/p\u003e\n\u003cp\u003eNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\u003c/p\u003e\n\u003ch2 id=\"heading-building-a-cli-agent\"\u003eBuilding a CLI Agent\u003c/h2\u003e\n\u003cp\u003eHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\u003c/p\u003e\n\u003cp\u003eAn \u003cstrong\u003einterface\u003c/strong\u003e describes a single-focused, composable contract through which components can interact with each other and with hosts.\u003c/p\u003e\n\u003cp\u003eInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., \u003cstrong\u003eexport\u003c/strong\u003e) or whether external code must fulfill the interface for the component to call (i.e., \u003cstrong\u003eimport\u003c/strong\u003e).\u003c/p\u003e\n\u003cp\u003eInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\u003c/p\u003e\n\u003cp\u003eHere is an example of how Hayride defines an agent runner interface using WIT:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e runner {\n    use types.{message};\n    use agents.{agent};\n    use wasi:io/streams@\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e.{output-stream};\n\n    enum error-code {\n        invoke-error,\n        unknown\n    }\n\n    resource error {\n        code: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e-\u003cspan class=\"hljs-title\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\n        data: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e;\u003c/span\u003e\n    }\n\n    invoke: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(message: message, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n    invoke-stream: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(message: message, writer: borrow\u0026lt;output-stream\u0026gt;, agent: borrow\u0026lt;agent\u0026gt;)\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;_,\u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(\u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eThe runner interface is responsible for invoking an agent and supplying a prompt or message.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRunners\u003c/strong\u003e define the agent loop as a function that describes how the agent executes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAgents\u003c/strong\u003e are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\u003c/p\u003e\n\u003cp\u003eOur agent interface in WIT is defined as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e hayride:ai@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e agents {\n    use types.{message};\n    use context.{context};\n    use model.{format};\n    use hayride:mcp/tools@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e.{tools};\n    use hayride:mcp/types@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e.{tool, call-tool-params, call-tool-result};\n    use graph-stream.{graph-stream};\n    use inference-stream.{graph-execution-context-stream};\n    use wasi:io/streams@\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e.{output-stream};\n\n    enum error-code {\n        capabilities-error,\n        context-error,\n        compute-error,\n        execute-error,\n        unknown\n    }\n\n    resource error {\n        code: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e-\u003cspan class=\"hljs-title\"\u003ecode\u003c/span\u003e;\u003c/span\u003e\n        data: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e;\u003c/span\u003e\n    }\n\n    resource agent {\n        constructor(name: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e, instruction: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e, format: format, graph: graph-execution-context-stream, tools: option\u0026lt;tools\u0026gt;, context: option\u0026lt;context\u0026gt;);\n        name: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e;\u003c/span\u003e\n        instruction: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003estring\u003c/span\u003e;\u003c/span\u003e\n        capabilities: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003etool\u003c/span\u003e\u0026gt;, \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n        context: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003elist\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003emessage\u003c/span\u003e\u0026gt;, \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n        compute: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(message: message)\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003emessage\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n        execute: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(params: call-tool-params)\u003c/span\u003e -\u0026gt; \u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003ecall\u003c/span\u003e-\u003cspan class=\"hljs-title\"\u003etool\u003c/span\u003e-\u003cspan class=\"hljs-title\"\u003eresult\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003eerror\u003c/span\u003e\u0026gt;;\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(\u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\"\u003ehttps://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\u003c/p\u003e\n\u003cp\u003eFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/morphs/tree/main/components\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\u003c/p\u003e\n\u003ch3 id=\"heading-defining-our-morph\"\u003eDefining Our Morph\u003c/h3\u003e\n\u003cp\u003eHayride Morphs are the fundamental building blocks of applications. They can \u003cstrong\u003eimport\u003c/strong\u003e functions to access external capabilities and can also \u003cstrong\u003eexport\u003c/strong\u003e their capabilities to other morphs.\u003c/p\u003e\n\u003cp\u003eThe term \u003cstrong\u003emorph\u003c/strong\u003e simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\u003c/p\u003e\n\u003cp\u003eOur CLI Agent Morph can be described in WIT using \u003cstrong\u003eworlds\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\u003c/p\u003e\n\u003cp\u003eConnecting up some or all of a component’s imports to other components’ matching exports is called \u003cstrong\u003ecomposition\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eGiven this, we can define our component world as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e hayride:example@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e;\n\nworld cli {\n    include hayride:wasip2/imports@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n    include hayride:wasip2/exports@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e hayride:ai/runner@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e hayride:ai/model-repository@\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.61\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(\u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\u003c/p\u003e\n\u003ch3 id=\"heading-project-setup\"\u003eProject Setup\u003c/h3\u003e\n\u003cp\u003eFirst, we create our project’s directory layout:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emkdir hayride-example-agent\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use \u003cstrong\u003ego mod\u003c/strong\u003e to initialize our application and dependencies:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ego mod init\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNext, we create a directory called wit:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emkdir wit\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe use the world defined above and copy it to a file in our wit directory:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etouch ./wit/world.wit\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using \u003cstrong\u003ewit-deps\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWit-deps requires a \u003ccode\u003edeps.toml\u003c/code\u003e to track dependencies. We can add it to our wit directory using the following command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTouch ./wit/deps.toml\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eIn the \u003ccode\u003edeps.toml\u003c/code\u003e file, add the following dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-ini\"\u003e\u003cspan class=\"hljs-attr\"\u003ewasip2\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eai\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emcp\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo pull these dependencies into our project, we use a tool called \u003cstrong\u003ewit-deps.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFrom the project’s root, run the following command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewit-deps update\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNext, we create a \u003ccode\u003emain.go\u003c/code\u003e file and start implementing our CLI application:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etouch main.go\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\u003c/p\u003e\n\u003ch3 id=\"heading-cli-application\"\u003eCLI Application\u003c/h3\u003e\n\u003cp\u003eOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\u003c/p\u003e\n\u003cp\u003eFirst, let’s start by creating the necessary objects using Hayride’s \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/bindings\"\u003ebindings repository\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn the \u003ccode\u003emain.go\u003c/code\u003e file, add the following lines of code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"hljs-string\"\u003e\"bufio\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"log\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"os\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"strings\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/agents\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/graph\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/models\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/runner\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/types\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/wasi/cli\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"go.bytecodealliance.org/cm\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    repo := repository.New()\n    path, err := repo.DownloadModel(\u003cspan class=\"hljs-string\"\u003e\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to download model:\"\u003c/span\u003e, err)\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\n    ctx, err := ctx.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create context:\"\u003c/span\u003e, err)\n    }\n\n    tools, err := tools.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create tools:\"\u003c/span\u003e, err)\n    }\n\n    format, err := models.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create model format:\"\u003c/span\u003e, err)\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// host provides a graph stream\u003c/span\u003e\n    inferenceStream, err := graph.LoadByName(path)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to load graph:\"\u003c/span\u003e, err)\n    }\n\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to initialize graph execution context stream:\"\u003c/span\u003e, err)\n    }\n\n    a, err := agents.New(\n        format, graphExecutionCtxStream,\n        agents.WithName(\u003cspan class=\"hljs-string\"\u003e\"Helpful Agent\"\u003c/span\u003e),\n        agents.WithInstruction(\u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant. Answer the user's questions to the best of your ability.\"\u003c/span\u003e),\n        agents.WithContext(ctx),\n        agents.WithTools(tools),\n    )\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create agent:\"\u003c/span\u003e, err)\n    }\n\n    runner := runner.New()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code simply creates the various objects that our runner and agent require to execute:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRepository:\u003c/strong\u003e The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eContext\u003c/strong\u003e: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTools\u003c/strong\u003e: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eFormat\u003c/strong\u003e: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eGraphExecutionCtxStream\u003c/strong\u003e: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of \u003ca target=\"_blank\" href=\"https://github.com/WebAssembly/wasi-nn/releases\"\u003ewasi-nn\u003c/a\u003e to allow for streaming responses.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext, we add the code to read from \u003cstrong\u003eSTDIN\u003c/strong\u003e and create a \u003cstrong\u003eSTDOUT\u003c/strong\u003e writer.\u003c/p\u003e\n\u003cp\u003eSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s \u003cstrong\u003eSTDIN/STDOUT\u003c/strong\u003e in our application.\u003c/p\u003e\n\u003cp\u003eWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an \u003ccode\u003eio.Writer\u003c/code\u003e when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\u003c/p\u003e\n\u003cp\u003eTo avoid this limitation, we have implemented a few WASI helpers in the \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/bindings/tree/main/go/wasi\"\u003ebindings repository\u003c/a\u003e. The main helper to leverage is our implementation of the \u003ca target=\"_blank\" href=\"https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit\"\u003e\u003cstrong\u003ewasi-cli\u003c/strong\u003e\u003c/a\u003e interface.\u003c/p\u003e\n\u003cp\u003eUsing our bindings, we can create an \u003ccode\u003eio.Writer\u003c/code\u003e that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003ewriter := cli.GetStdout(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\nreader := bufio.NewReader(os.Stdin)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003efmt.Println(\u003cspan class=\"hljs-string\"\u003e\"What can I help with?\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e {\n    input, _ := reader.ReadString(\u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e)\n    prompt := strings.TrimSpace(input)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\"hljs-string\"\u003e\"exit\"\u003c/span\u003e {\n        fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"Goodbye!\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    }\n\n    msg := types.Message{\n        Role: types.RoleUser,\n        Content: cm.ToList([]types.MessageContent{\n            types.NewMessageContent(types.Text(input)),\n        }),\n    }\n\n    err := runner.InvokeStream(msg, writer, a)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"error invoking agent:\"\u003c/span\u003e, err)\n        os.Exit(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    }\n\n    fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"\\nWhat else can I help with? (type 'exit' to quit)\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe runner’s \u003cstrong\u003eInvokeStream\u003c/strong\u003e function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\u003c/p\u003e\n\u003cp\u003eThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the \u003ca target=\"_blank\" href=\"https://wasi.dev/roadmap?utm_source=chatgpt.com\"\u003ewasi roadmap\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe full code looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"hljs-string\"\u003e\"bufio\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"log\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"os\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"strings\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/agents\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/graph\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/models\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/ai/runner\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/hayride/types\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"github.com/hayride-dev/bindings/go/wasi/cli\"\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"go.bytecodealliance.org/cm\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    repo := repository.New()\n    path, err := repo.DownloadModel(\u003cspan class=\"hljs-string\"\u003e\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to download model:\"\u003c/span\u003e, err)\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// Initialize the context, tools, and model format\u003c/span\u003e\n    ctx, err := ctx.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create context:\"\u003c/span\u003e, err)\n    }\n\n    tools, err := tools.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create tools:\"\u003c/span\u003e, err)\n    }\n\n    format, err := models.New()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create model format:\"\u003c/span\u003e, err)\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// host provides a graph stream\u003c/span\u003e\n    inferenceStream, err := graph.LoadByName(path)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to load graph:\"\u003c/span\u003e, err)\n    }\n\n    graphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to initialize graph execution context stream:\"\u003c/span\u003e, err)\n    }\n\n    a, err := agents.New(\n        format, graphExecutionCtxStream,\n        agents.WithName(\u003cspan class=\"hljs-string\"\u003e\"Helpful Agent\"\u003c/span\u003e),\n        agents.WithInstruction(\u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant. Answer the user's questions to the best of your ability.\"\u003c/span\u003e),\n        agents.WithContext(ctx),\n        agents.WithTools(tools),\n    )\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n        log.Fatal(\u003cspan class=\"hljs-string\"\u003e\"failed to create agent:\"\u003c/span\u003e, err)\n    }\n\n    runner := runner.New()\n\n    writer := cli.GetStdout(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n    reader := bufio.NewReader(os.Stdin)\n\n    fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"What can I help with?\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e {\n        input, _ := reader.ReadString(\u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e)\n        prompt := strings.TrimSpace(input)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e strings.ToLower(prompt) == \u003cspan class=\"hljs-string\"\u003e\"exit\"\u003c/span\u003e {\n            fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"Goodbye!\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n        }\n\n        msg := types.Message{\n            Role: types.RoleUser,\n            Content: cm.ToList([]types.MessageContent{\n                types.NewMessageContent(types.Text(input)),\n            }),\n        }\n\n        err := runner.InvokeStream(msg, writer, a)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n            fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"error invoking agent:\"\u003c/span\u003e, err)\n            os.Exit(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        }\n\n        fmt.Println(\u003cspan class=\"hljs-string\"\u003e\"\\nWhat else can I help with? (type 'exit' to quit)\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(\u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\"\u003ehttps://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eAll that’s left is to build and deploy our agent onto Hayride!\u003c/p\u003e\n\u003cp\u003eWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\u003c/p\u003e\n\u003ch3 id=\"heading-build-composition-and-deployment\"\u003eBuild Composition and Deployment\u003c/h3\u003e\n\u003cp\u003eTo compose our CLI with the existing Wasm components supplied by Hayride, we use \u003cstrong\u003eWAC,\u003c/strong\u003e a tool for composing WebAssembly Components together. The source code for these components can be found in our \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev/morphs/tree/main/components\"\u003emorphs repository\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe full language guide for WAC can be found \u003ca target=\"_blank\" href=\"https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe start by creating a \u003ccode\u003ecli.wac\u003c/code\u003e with the following content:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-bash\"\u003epackage hayride:example;\n\n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e context = new hayride:inmemory@0.0.1 {...}; \n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e llama = new hayride:llama31@0.0.1 {...};\n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e tools = new hayride:default-tools@0.0.1 {...};\n\n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e agent = new hayride:default-agent@0.0.1 {\n  context: context.context,\n  model: llama.model,\n  tools: tools.tools,\n  ...\n};\n\n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e runner = new hayride:default-runner@0.0.1 {\n  agents: agent.agents,\n  ...\n};\n\n\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e cli = new hayride:cli@0.0.1 {\n  context: context.context,\n  model: llama.model,\n  tools: tools.tools,\n  agents: agent.agents,\n  runner: runner.runner,\n  ...\n};\n\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e cli...;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\u003c/p\u003e\n\u003cp\u003eIn the above file, we are using the following Hayride Morphs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003ehayride:inmemory@0.0.1\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ehayride:llama31@0.0.1\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ehayride:default-tools@0.0.1\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ehayride:default-agent@0.0.1\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ehayride:default-runner@0.0.1\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\u003c/p\u003e\n\u003cp\u003eHayride has built-in support for WAC files, and we can execute our composition with the following command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eOnce we have the \u003ccode\u003ecomposed-cli-agent.wasm\u003c/code\u003e file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eAll that’s left is to execute our morph:\u003cbr /\u003e\u003ccode\u003ehayride cast --package hayride:composed-cli-agent@0.0.1 -it\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis command launches our CLI:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK\" alt /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\u003c/p\u003e\n\u003cp\u003eIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\u003c/p\u003e\n\u003cp\u003eTo stay informed about future developments, follow us on \u003ca target=\"_blank\" href=\"https://x.com/HayrideDev\"\u003eX\u003c/a\u003e and \u003ca target=\"_blank\" href=\"https://github.com/hayride-dev\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\n","markdown":"# Overview\n\n[In our last post](https://blog.hayride.dev/sandboxing-ai), we announced Hayride, an open-source secure AI runtime for LLMs, sandboxed code execution, and orchestrating agentic workflows.\n\nHayride leverages the [security](https://webassembly.org/docs/security/) and [por](https://webassembly.org/docs/security/)[tability](https://webassembly.org/docs/portability/) benefits offered by WebAssembly, making it an ideal platform for developers focused on building composable and reusable AI tooling.\n\nIn a series of posts this one kicks off, we will explore building a lightweight command-line (CLI) AI agent using **Golang**, with a sprinkle of **Rust**, to demonstrate how quickly AI agents leveraging tools written in multiple languages can be composed together using Hayride.\n\nIf you are new to WebAssembly and concepts such as WebAssembly Interface Types, WebAssembly System Interfaces, or the component model, we recommend learning about these topics now. However, this post will guide you through the various concepts as they come up.\n\nHere are some resources to get you up to speed on WebAssembly:\n\n* [https://wasi.dev/](https://wasi.dev/)\n    \n* [https://component-model.bytecodealliance.org/introduction.html](https://component-model.bytecodealliance.org/introduction.html)\n    \n* [https://docs.hayride.dev/platform/concepts/wasm](https://docs.hayride.dev/platform/concepts/wasm)\n    \n\nLet’s dive in!\n\n## Prerequisites\n\nBefore we can start implementing our application, several tools are required. Of note, Hayride leverages [WASI Preview 2](https://wasi.dev/interfaces#wasi-02), which is gaining support across various languages.\n\nWe’ll use the following tools in this post:\n\n* [Hayride](https://github.com/hayride-dev/releases)\n    \n* [Wit-bindgen-go](https://github.com/bytecodealliance/go-modules?tab=readme-ov-file#wit-bindgen-go)\n    \n* [Wit-deps](https://github.com/bytecodealliance/wit-deps)\n    \n* [Wac](https://github.com/bytecodealliance/wac)\n    \n* [Go](https://go.dev/doc/install) version 1.23.0+\n    \n* [TinyGo](https://tinygo.org/) version 0.33.0+\n    \n* [Rust +nightly](https://www.rust-lang.org/tools/install)\n    \n* [Cargo component](https://github.com/bytecodealliance/cargo-component)\n    \n\nPlease refer to the tools’ installation guides to get started.\n\n### Installing Hayride\n\nThe easiest way to install Hayride is through our installation script. Linux and macOS users can execute the following:\n\n`curl https://raw.githubusercontent.com/hayride-dev/releases/refs/heads/main/install.sh -sSf | bash`\n\nThis downloads a precompiled version of wasmtime, places it in $HOME/.hayride, and updates your shell configuration to set the right directory in PATH.\n\nWindows users can visit our releases page to download the [MSI installer](https://github.com/hayride-dev/releases/releases/download/v0.0.3-alpha/hayride-v0.0.3-alpha-x86_64-windows.msi) and use it to install Hayride.\n\nAfter the installation completes, the hayride binary should be located in your path. You can verify the installation by running `hayride help` from your terminal.\n\nNow that Hayride is installed, we can start developing an agent that can be deployed to Hayride!\n\n## Building a CLI Agent\n\nHayride has defined a set of AI interfaces using WebAssembly Interface Types (WIT).\n\nAn **interface** describes a single-focused, composable contract through which components can interact with each other and with hosts.\n\nInterfaces are directional. When using an interface, you can indicate whether the interface is available for external code to call (i.e., **export**) or whether external code must fulfill the interface for the component to call (i.e., **import**).\n\nInterfaces are strictly bound to a component. A component cannot interact with anything outside itself except by having its exports called or by calling its imports. These constraints provide rigorous sandboxing.\n\nHere is an example of how Hayride defines an agent runner interface using WIT:\n\n```go\npackage hayride:ai@0.0.61;\n\ninterface runner {\n    use types.{message};\n    use agents.{agent};\n    use wasi:io/streams@0.2.0.{output-stream};\n\n    enum error-code {\n        invoke-error,\n        unknown\n    }\n\n    resource error {\n        code: func() -\u003e error-code;\n        data: func() -\u003e string;\n    }\n\n    invoke: func(message: message, agent: borrow\u003cagent\u003e) -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\n    invoke-stream: func(message: message, writer: borrow\u003coutput-stream\u003e, agent: borrow\u003cagent\u003e) -\u003e result\u003c_,error\u003e;\n}\n```\n\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/runner.wit))\n\nThe runner interface is responsible for invoking an agent and supplying a prompt or message.\n\n**Runners** define the agent loop as a function that describes how the agent executes.\n\n**Agents** are defined as a component that interacts with an AI model, can use tools, and can store the context of any interactions.\n\nOur agent interface in WIT is defined as follows:\n\n```go\npackage hayride:ai@0.0.61;\n\ninterface agents {\n    use types.{message};\n    use context.{context};\n    use model.{format};\n    use hayride:mcp/tools@0.0.61.{tools};\n    use hayride:mcp/types@0.0.61.{tool, call-tool-params, call-tool-result};\n    use graph-stream.{graph-stream};\n    use inference-stream.{graph-execution-context-stream};\n    use wasi:io/streams@0.2.0.{output-stream};\n\n    enum error-code {\n        capabilities-error,\n        context-error,\n        compute-error,\n        execute-error,\n        unknown\n    }\n\n    resource error {\n        code: func() -\u003e error-code;\n        data: func() -\u003e string;\n    }\n\n    resource agent {\n        constructor(name: string, instruction: string, format: format, graph: graph-execution-context-stream, tools: option\u003ctools\u003e, context: option\u003ccontext\u003e);\n        name: func() -\u003e string;\n        instruction: func() -\u003e string;\n        capabilities: func() -\u003e result\u003clist\u003ctool\u003e, error\u003e;\n        context: func() -\u003e result\u003clist\u003cmessage\u003e, error\u003e;\n        compute: func(message: message) -\u003e result\u003cmessage, error\u003e;\n        execute: func(params: call-tool-params) -\u003e result\u003ccall-tool-result, error\u003e;\n    }\n}\n```\n\n([https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit](https://github.com/hayride-dev/coven/blob/main/ai/wit/agents.wit))\n\nFollowing the component model, these interfaces can be implemented externally by outside code and imported by our component.\n\nFor this post, we use a default runner and agent implementation packaged with Hayride. This allows us to focus solely on the CLI portion of our agent and uses an externally available runner and agent component that satisfy our interface contracts. The implementations of these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\n\nIn a future post, we will unpack how each of these components works and how you can implement your own component that satisfies the various AI interfaces Hayride supplies.\n\n### Defining Our Morph\n\nHayride Morphs are the fundamental building blocks of applications. They can **import** functions to access external capabilities and can also **export** their capabilities to other morphs.\n\nThe term **morph** simply refers to a WebAssembly component that is designed to be composable and portable across different environments.\n\nOur CLI Agent Morph can be described in WIT using **worlds**.\n\nA WIT world is a higher-level contract that describes a component’s capabilities and needs. A world is composed of interfaces. For a component to run, its imports must be fulfilled by a host or by other components.\n\nConnecting up some or all of a component’s imports to other components’ matching exports is called **composition**.\n\nGiven this, we can define our component world as follows:\n\n```go\npackage hayride:example@0.0.1;\n\nworld cli {\n    include hayride:wasip2/imports@0.0.61;\n    include hayride:wasip2/exports@0.0.61;\n    \n    import hayride:ai/runner@0.0.61;\n    import hayride:ai/model-repository@0.0.61;\n}\n```\n\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/wit/world.wit#L3C1-L9C2))\n\nNow that we have a rough idea of what our world and interfaces look like, we can create our project and see how we use the preceding WIT definitions.\n\n### Project Setup\n\nFirst, we create our project’s directory layout:\n\n`mkdir hayride-example-agent`\n\nSince we are building our agent in Go and compiling to WebAssembly using TinyGo, we can use **go mod** to initialize our application and dependencies:\n\n`go mod init`\n\nNext, we create a directory called wit:\n\n`mkdir wit`\n\nWe use the world defined above and copy it to a file in our wit directory:\n\n`touch ./wit/world.wit`\n\nTo use this world, we need to pull down our dependencies. Using Hayride’s WIT repository, we can add two dependencies using **wit-deps**.\n\nWit-deps requires a `deps.toml` to track dependencies. We can add it to our wit directory using the following command:\n\n`Touch ./wit/deps.toml`\n\nIn the `deps.toml` file, add the following dependencies:\n\n```ini\nwasip2 = \"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_wasip2_v0.0.61.tar.gz\"\nai = \"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_ai_v0.0.61.tar.gz\"\nmcp = \"https://github.com/hayride-dev/coven/releases/download/v0.0.61/hayride_mcp_v0.0.61.tar.gz\"\n```\n\nTo pull these dependencies into our project, we use a tool called **wit-deps.**\n\nFrom the project’s root, run the following command:\n\n`wit-deps update`\n\nNext, we create a `main.go` file and start implementing our CLI application:\n\n`touch main.go`\n\nNow that we have the basic project layout and dependencies downloaded, we can move on to implementing our CLI.\n\n### CLI Application\n\nOur CLI is responsible for reading in a user’s message from STDIN and returning the response from the agent.\n\nFirst, let’s start by creating the necessary objects using Hayride’s [bindings repository](https://github.com/hayride-dev/bindings).\n\nIn the `main.go` file, add the following lines of code:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/agents\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/graph\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/models\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/runner\"\n\t\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\"\n\t\"github.com/hayride-dev/bindings/go/hayride/types\"\n\t\"github.com/hayride-dev/bindings/go/wasi/cli\"\n\t\"go.bytecodealliance.org/cm\"\n)\n\nfunc main() {\n\trepo := repository.New()\n\tpath, err := repo.DownloadModel(\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\")\n\tif err != nil {\n\t\tlog.Fatal(\"failed to download model:\", err)\n\t}\n\n\t// Initialize the context, tools, and model format\n\tctx, err := ctx.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create context:\", err)\n\t}\n\n\ttools, err := tools.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create tools:\", err)\n\t}\n\n\tformat, err := models.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create model format:\", err)\n\t}\n\n\t// host provides a graph stream\n\tinferenceStream, err := graph.LoadByName(path)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to load graph:\", err)\n\t}\n\n\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to initialize graph execution context stream:\", err)\n\t}\n\n\ta, err := agents.New(\n\t\tformat, graphExecutionCtxStream,\n\t\tagents.WithName(\"Helpful Agent\"),\n\t\tagents.WithInstruction(\"You are a helpful assistant. Answer the user's questions to the best of your ability.\"),\n\t\tagents.WithContext(ctx),\n\t\tagents.WithTools(tools),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create agent:\", err)\n\t}\n\n\trunner := runner.New()\n}\n```\n\nThis code simply creates the various objects that our runner and agent require to execute:\n\n* **Repository:** The repository package provides the ability to download models from a remote repository. Hayride’s host environment provides a Hugging Face implementation for model repositories.\n    \n* **Context**: The context object is a message store for the agent. The agent determines when to store context and when to pull past messages. We’re using Hayride’s in-memory context store for this example.\n    \n* **Tools**: The tools object is used to expose callable tools to the agent. Since our agent doesn’t require tools, we’ll attach an empty tools component.\n    \n* **Format**: The format object is used to encode the user’s message before sending it to the LLM. We also use the format object to decode the response from the LLM. Each model typically requires some form of custom encoding or decoding.\n    \n* **GraphExecutionCtxStream**: The GraphExecutionCtxStream provides access to our host environment and the LLM loaded. This is an extension of [wasi-nn](https://github.com/WebAssembly/wasi-nn/releases) to allow for streaming responses.\n    \n\nNext, we add the code to read from **STDIN** and create a **STDOUT** writer.\n\nSince we are working with WebAssembly, we leverage WASI to pipe the terminal’s **STDIN/STDOUT** in our application.\n\nWhile TinyGo supports wasip2, a few limitations come up when composing multiple components. One of these limitations is the inability to access the Wasm resource provisioned by the host runtime for an `io.Writer` when using the Standard library. In short, this means that we are unable to pass this resource to a component that uses this resource.\n\nTo avoid this limitation, we have implemented a few WASI helpers in the [bindings repository](https://github.com/hayride-dev/bindings/tree/main/go/wasi). The main helper to leverage is our implementation of the [**wasi-cli**](https://github.com/WebAssembly/wasi-cli/blob/main/wit/stdio.wit) interface.\n\nUsing our bindings, we can create an `io.Writer` that can be converted into a WASI output stream and passed between components, in our case, passing the writer created in our CLI application to an AI runner:\n\n```go\nwriter := cli.GetStdout(true)\nreader := bufio.NewReader(os.Stdin)\n```\n\nLastly, we add a basic loop that allows the user to type a prompt, send the prompt to the agent using our runner, and display the result:\n\n```go\nfmt.Println(\"What can I help with?\")\nfor {\n\tinput, _ := reader.ReadString('\\n')\n\tprompt := strings.TrimSpace(input)\n\tif strings.ToLower(prompt) == \"exit\" {\n\t\tfmt.Println(\"Goodbye!\")\n\t\tbreak\n\t}\n\n\tmsg := types.Message{\n\t\tRole: types.RoleUser,\n\t\tContent: cm.ToList([]types.MessageContent{\n\t\t\ttypes.NewMessageContent(types.Text(input)),\n\t\t}),\n\t}\n\n\terr := runner.InvokeStream(msg, writer, a)\n\tif err != nil {\n\t\tfmt.Println(\"error invoking agent:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"\\nWhat else can I help with? (type 'exit' to quit)\")\n}\n```\n\nThe runner’s **InvokeStream** function is called with the user’s prompt, an output stream, and an agent. The result of the agent is automatically written back to the user. We simply invoke our agent in a loop with the message the user has sent.\n\nThere are limitations with WebAssembly’s async capabilities that require us to pass the writer forward to our component in order to start writing the result as fast as possible. However, discussions around async functions are taking place in wasip3. More information can be found on the [wasi roadmap](https://wasi.dev/roadmap?utm_source=chatgpt.com).\n\nThe full code looks like this:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/agents\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/ctx\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/graph\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/models\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/models/repository\"\n\t\"github.com/hayride-dev/bindings/go/hayride/ai/runner\"\n\t\"github.com/hayride-dev/bindings/go/hayride/mcp/tools\"\n\t\"github.com/hayride-dev/bindings/go/hayride/types\"\n\t\"github.com/hayride-dev/bindings/go/wasi/cli\"\n\t\"go.bytecodealliance.org/cm\"\n)\n\nfunc main() {\n\trepo := repository.New()\n\tpath, err := repo.DownloadModel(\"bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf\")\n\tif err != nil {\n\t\tlog.Fatal(\"failed to download model:\", err)\n\t}\n\n\t// Initialize the context, tools, and model format\n\tctx, err := ctx.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create context:\", err)\n\t}\n\n\ttools, err := tools.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create tools:\", err)\n\t}\n\n\tformat, err := models.New()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create model format:\", err)\n\t}\n\n\t// host provides a graph stream\n\tinferenceStream, err := graph.LoadByName(path)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to load graph:\", err)\n\t}\n\n\tgraphExecutionCtxStream, err := inferenceStream.InitExecutionContextStream()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to initialize graph execution context stream:\", err)\n\t}\n\n\ta, err := agents.New(\n\t\tformat, graphExecutionCtxStream,\n\t\tagents.WithName(\"Helpful Agent\"),\n\t\tagents.WithInstruction(\"You are a helpful assistant. Answer the user's questions to the best of your ability.\"),\n\t\tagents.WithContext(ctx),\n\t\tagents.WithTools(tools),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to create agent:\", err)\n\t}\n\n\trunner := runner.New()\n\n\twriter := cli.GetStdout(true)\n\treader := bufio.NewReader(os.Stdin)\n\n\tfmt.Println(\"What can I help with?\")\n\tfor {\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tprompt := strings.TrimSpace(input)\n\t\tif strings.ToLower(prompt) == \"exit\" {\n\t\t\tfmt.Println(\"Goodbye!\")\n\t\t\tbreak\n\t\t}\n\n\t\tmsg := types.Message{\n\t\t\tRole: types.RoleUser,\n\t\t\tContent: cm.ToList([]types.MessageContent{\n\t\t\t\ttypes.NewMessageContent(types.Text(input)),\n\t\t\t}),\n\t\t}\n\n\t\terr := runner.InvokeStream(msg, writer, a)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error invoking agent:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tfmt.Println(\"\\nWhat else can I help with? (type 'exit' to quit)\")\n\t}\n}\n```\n\n([https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go](https://github.com/hayride-dev/morphs/blob/main/components/examples/agents/cli.go))\n\nAll that’s left is to build and deploy our agent onto Hayride!\n\nWe’ll compile our application, compose it with Hayride’s existing morphs, and deploy our composed morph to Hayride.\n\n### Build Composition and Deployment\n\nTo compose our CLI with the existing Wasm components supplied by Hayride, we use **WAC,** a tool for composing WebAssembly Components together. The source code for these components can be found in our [morphs repository](https://github.com/hayride-dev/morphs/tree/main/components).\n\nThe full language guide for WAC can be found [here](https://github.com/bytecodealliance/wac/blob/main/LANGUAGE.md).\n\nWe start by creating a `cli.wac` with the following content:\n\n```bash\npackage hayride:example;\n\nlet context = new hayride:inmemory@0.0.1 {...}; \nlet llama = new hayride:llama31@0.0.1 {...};\nlet tools = new hayride:default-tools@0.0.1 {...};\n\nlet agent = new hayride:default-agent@0.0.1 {\n  context: context.context,\n  model: llama.model,\n  tools: tools.tools,\n  ...\n};\n\nlet runner = new hayride:default-runner@0.0.1 {\n  agents: agent.agents,\n  ...\n};\n\nlet cli = new hayride:cli@0.0.1 {\n  context: context.context,\n  model: llama.model,\n  tools: tools.tools,\n  agents: agent.agents,\n  runner: runner.runner,\n  ...\n};\n\nexport cli...;\n```\n\nThis file is responsible for composing the Wasm components that satisfy the interfaces our runner and agent expect.\n\nIn the above file, we are using the following Hayride Morphs:\n\n* hayride:inmemory@0.0.1\n    \n* hayride:llama31@0.0.1\n    \n* hayride:default-tools@0.0.1\n    \n* hayride:default-agent@0.0.1\n    \n* hayride:default-runner@0.0.1\n    \n\nUsing these components, we can compose our CLI. The final result is a single Wasm module that can be deployed on Hayride.\n\nHayride has built-in support for WAC files, and we can execute our composition with the following command:\n\n`hayride wac compose --path ./cli.wac --out ./composed-cli-agent.wasm`\n\nOnce we have the `composed-cli-agent.wasm` file, we can register it with Hayride. This makes the morph available for future composition and direct execution.\n\n`hayride register --bin ./cli-agent.wasm --package hayride:composed-cli-agent@0.0.1`\n\nAll that’s left is to execute our morph:   \n`hayride cast --package hayride:composed-cli-agent@0.0.1 -it`\n\nThis command launches our CLI:\n\n![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnunFoEQ-rmBxnonyKtdkK2dhB4ZIw_VnxxzpGwFRQVqoGet5Yi9Xxt9JnC1BxmYJ8cVUklDceFXLq8ELxc7zDErb1Ft3T_FbJyXzwz1t9EQa3L09z13qc5pdApF42VzqEFVV-?key=HJZoXeiqMu56XW0ZbuwWHuiK align=\"left\")\n\n## Conclusion\n\nIn this post, we have demonstrated how to build a CLI application using Hayride’s existing AI morphs. Using WebAssembly’s Component model and various community tools, we composed multiple components together to build and deploy our CLI application on Hayride.\n\nIn our next post, we will delve into the Hayride Agent and Runner, exploring how each of these components works.\n\nTo stay informed about future developments, follow us on [X](https://x.com/HayrideDev) and [GitHub](https://github.com/hayride-dev)."},"views":494,"preferences":{"pinnedToBlog":false,"disableComments":true,"stickCoverToBottom":false,"isDelisted":false},"readTimeInMinutes":11,"series":null,"tags":[{"id":"56744721958ef13879b94e1c","slug":"golang","name":"golang"},{"id":"56744722958ef13879b95043","slug":"webassembly","name":"WebAssembly"},{"id":"56744721958ef13879b9488e","slug":"ai","name":"AI"},{"id":"6347ba4bad721d4c5133e3c2","slug":"ai-tools","name":"#ai-tools"},{"id":"635ad52efe8087002dee4707","slug":"llm","name":"llm"}],"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1754066340300/28af3dcf-9f58-4299-b182-9be5216337bc.jpeg"},"canonicalUrl":null,"hasLatexInPost":false,"audioUrls":null,"isFollowed":null,"bookmarked":false,"features":{"tableOfContents":{"isEnabled":true,"items":[{"__typename":"TableOfContentsItem","id":"c62e2bf4-0455-461a-8816-5e66e4315fe5","level":1,"slug":"overview","title":"Overview","parentId":null},{"__typename":"TableOfContentsItem","id":"851dff37-fd27-41cd-b828-eb0ba56a7146","level":2,"slug":"prerequisites","title":"Prerequisites","parentId":"c62e2bf4-0455-461a-8816-5e66e4315fe5"},{"__typename":"TableOfContentsItem","id":"7a129beb-fd1a-41e5-a602-388021ed3f6a","level":3,"slug":"installing-hayride","title":"Installing Hayride","parentId":"851dff37-fd27-41cd-b828-eb0ba56a7146"},{"__typename":"TableOfContentsItem","id":"5d1ec457-096e-4248-8576-4d29e46d34d9","level":2,"slug":"building-a-cli-agent","title":"Building a CLI Agent","parentId":"c62e2bf4-0455-461a-8816-5e66e4315fe5"},{"__typename":"TableOfContentsItem","id":"d97e814c-4f20-4902-8f53-0d70fa9999a3","level":3,"slug":"defining-our-morph","title":"Defining Our Morph","parentId":"5d1ec457-096e-4248-8576-4d29e46d34d9"},{"__typename":"TableOfContentsItem","id":"294da59e-c03c-4d11-9bad-251d1d8e5516","level":3,"slug":"project-setup","title":"Project Setup","parentId":"5d1ec457-096e-4248-8576-4d29e46d34d9"},{"__typename":"TableOfContentsItem","id":"b4ac9c3c-ee04-49f3-ba49-2467d4f0a542","level":3,"slug":"cli-application","title":"CLI Application","parentId":"5d1ec457-096e-4248-8576-4d29e46d34d9"},{"__typename":"TableOfContentsItem","id":"701498c3-5104-40f8-822e-2935909a0747","level":3,"slug":"build-composition-and-deployment","title":"Build Composition and Deployment","parentId":"5d1ec457-096e-4248-8576-4d29e46d34d9"},{"__typename":"TableOfContentsItem","id":"9292c17a-23da-4664-b4ec-c5983894fbf8","level":2,"slug":"conclusion","title":"Conclusion","parentId":"c62e2bf4-0455-461a-8816-5e66e4315fe5"}]},"badges":{"isEnabled":true,"items":[]}},"isAutoPublishedFromRSS":false,"authenticatedUserLikes":{"edges":[]},"totalUserLikes":{"totalDocuments":1},"isShadowBanned":false,"isAskMeAnything":false},"redirectedPost":null,"staticPage":null},"series":null}},"__N_SSP":true},"page":"/[...slug]","query":{"x-host":"blog.hayride.dev","slug":["composable-agents"]},"buildId":"YNdX74WR8L1Q36DPndWD2","isFallback":false,"dynamicIds":[87179],"gssp":true,"scriptLoader":[]}</script><div id="hn-modal"></div><div id="hn-toast"></div></body></html>