# AI 代码助手正在超越自动补全：接下来是什么

直到最近，AI 代码助手这个术语还与自动补全功能同义。这是有原因的。AI 辅助代码补全功能，它会在开发者输入时预测并建议接下来的几个字符、单词或行，是根据工作流程和需要提供相关帮助的一个很好的例子。我从事专业[编写和维护代码](https://thenewstack.io/its-no-longer-about-how-you-write-code-but-how-you-operate-it/)已有20多年了。在 AI 辅助代码补全之前，各种开发者工具已经通过依赖 IDE 中内置的语言服务器功能提供了类似的功能。因此，AI 驱动的代码补全感觉像是 IDE 及其为开发者提供的帮助的自然发展步骤。

另一种流行的 AI 交互方式，即聊天界面，对于[开发者来说并不被认为非常有价值，因为它主要只回答通用查询](https://thenewstack.io/openais-chatgpt-now-formats-output-to-developer-queries/)，例如“如何反转链表？”，而这在开发者的日常工作中并不需要。

因此，完成接受率 (CAR)（一个计算开发者接受 AI 建议完成的百分比的指标）成为许多 AI 代码工具的关键绩效指标。代码工具的营销材料重点介绍了它们的自动补全功能，通常展示它们如何能够[通过减少](https://thenewstack.io/how-sdks-can-reduce-api-integration-time/)击键次数来节省[开发人员的时间]。

然而，这种情况正在改变。

**使自动补全有用的“流程”也限制了它**

当你坐下来编写一段代码时，代码会神奇地出现在你的屏幕上，这可能是一种真正类似于流程的体验。然而，同样的“上下文”质量——在你需要的时候，在你需要的地方提供帮助——使自动补全变得有帮助，这也是限制其效用的原因：

* **范围有限**: 编写代码——一项极其依赖人的活动——以人的速度进行。此外，编写代码甚至并非一直是主要的开发者活动。
* **上下文狭窄**: 自动补全逐行工作，缺乏对代码更广泛上下文或开发者意图的理解。
* **对延迟敏感**: 必须尽快提供补全，这限制了可以使用的 AI 模型。任何提供建议的延迟都会扰乱开发者的流程。

因此，由此带来的[软件开发速度](https://thenewstack.io/optimize-your-inner-dev-loop-to-increase-developer-velocity/)的提高充其量只是渐进式的。

**解决复杂的软件问题不仅仅需要编写代码**

我们看到[开发者使用 AI 工具的方式正在发生转变](https://thenewstack.io/how-ai-is-shifting-developer-culture-and-work-at-github/)。AI 代码助手仅仅完成你的代码行已经不够了。工程团队的需求更多。他们希望[解决更复杂的问题](https://thenewstack.io/the-complexity-of-solving-performance-problems/)。他们希望生成全新的功能，重构遗留代码，将代码现代化到更新的语言和框架版本，提高代码测试覆盖率，提高对安全和编码标准的合规性，等等。所有这些都无法通过自动补全来完成。它需要对组织更广泛的代码库（超出开发者同时处理的几个文件）有更深入的理解。大多数 AI 代码助手都缺乏这种能力。

截至今天，此类任务的最佳界面是良好的 AI 驱动的聊天。开发人员意识到，同样的聊天如果缺乏上下文，可能会过于通用而无用（记住反转链表？），但在拥有适当的上下文时，它会变成一台强大的机器。这就解释了为什么开发人员转向面向聊天的编程 (CHOP) 或通过迭代提示改进进行编码来解决他们的问题。

让我们来看一个面向聊天编程如何帮助我的最新例子。我正在开发一个处理大量视频内容的应用程序。用户会上传视频，我的服务需要将它们编码成各种格式，创建剪辑，将音频提取到 .mp3 文件中，等等。


许多这些操作都将非常计算密集型，因此我需要构建一个排队系统，该系统可以调度作业，在资源可用时处理任务，并在任务完成后更新队列。我最初通过依赖 Redis（一个用于创建排队系统的强大的键值存储）构建了所有功能。
我的实现方案在测试中运行良好，但一旦上线并开始使用我构建的排队系统，我很快意识到我的实现方案更适合关系数据库。该系统依赖于我需要访问的各种属性，这意味着必须查询大量不必要的数据才能从Redis获取我需要的键值对。将所有内容重写为使用SQLite将是一项相当大的工作。尽管如此，由于面向聊天的编程，我只需在我的编码助手之间通过几条聊天消息，并使用我的代码库作为上下文，就可以进行这项代码库范围内的更改。

AI编码助手不仅为我提供了关于需要发生什么的逐步说明，而且还生成了可工作的代码，用SQLite数据库查询替换了现有的Redis调用，生成了与我在Redis中使用的匹配的正确模式，并为我提供了关于去哪里以及更新什么的精确说明，从而节省了我无数小时的手动迁移工作。说到迁移，我还让我的编码助手编写了新的功能，将Redis中所有现有的作业数据迁移到SQLite，以便在新版本部署时不会丢失任何数据。

**成功取决于结果，而非输出**

随着这一演变，成功的衡量标准也发生了变化。完成接受率 (CAR) 仍然很重要，但不再是黄金标准。相反，工程团队正在关注更全面的衡量指标：

* **节省的时间**: 使用此工具减少了多少总体开发时间？
* **问题解决能力**: 此工具能否帮助解决复杂的编码难题？
* **代码质量改进**: 此工具能否帮助提高代码库的整体质量和可维护性？
* **学习和适应**: 此工具如何适应项目特定的需求和编码风格？

**展望未来**

即使在AI使用成为编码主流的最初两年中，使用模式也从更“代码输入”的活动迅速发展到更具迭代性设计或转换的活动。随着我们继续前进，很明显，自动完成虽然仍然有用，但这只是AI辅助编码的冰山一角。编码与在编辑器中努力地进行输入的日子已经过去了。

未来属于更全面、更上下文感知的AI系统，这些系统能够真正理解并协助软件开发。我们如何定义编码技能以及未来软件工作的培训方式可能与今天的有所不同。通过智能提示最有效地利用AI，并结合其他有助于理解代码的工具，可能会成为软件构建方式的重要方面。

*本文是The New Stack贡献者网络的一部分。对影响开发人员的最新挑战和创新有见解吗？我们很乐意听到您的声音。成为贡献者并分享您的专业知识，请填写此表格或发送电子邮件至mattburns@thenewstack.io。*

[YOUTUBE.COM/THENEWSTACK 技术发展迅速，不要错过任何一集。订阅我们的YouTube频道，收看我们所有的播客、访谈、演示等等。](https://youtube.com/thenewstack?sub_confirmation=1)