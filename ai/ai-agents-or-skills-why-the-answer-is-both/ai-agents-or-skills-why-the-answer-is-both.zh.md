在[模型上下文协议 (MCP)](https://thenewstack.io/model-context-protocol-a-primer-for-the-developers/)的热度还未消退之前，Anthropic 又出奇制胜地推出了[Agent Skills](https://thenewstack.io/agent-skills-anthropics-next-bid-to-define-ai-standards/)。

智能体是完整的决策实体，拥有系统提示、工具访问、支持模型（Claude、ChatGPT 等）以及允许它们编排工作流和管理状态的智能体循环。

[新的 Agent Skills](https://agentskills.io/home) 是模块化、声明式的专业知识包——将组织化的程序性知识打包成可重用单元，智能体可根据需要逐步加载。

这提出一个有趣且基础的架构问题：什么是智能体，什么应该是技能？这个选择对范围管理、上下文窗口可靠性、可扩展性和可评估性都有实际影响。

答案不是非此即彼。而是智能体与技能结合。

## **为什么仅靠提示无法扩展智能体**

早期的智能体系统遇到了可预见的瓶颈。团队为每个用例构建了专门的智能体：客户服务智能体、编码智能体、研究智能体。当这些智能体需要新功能时，开发人员会更新系统提示或创建一个全新的智能体。这可行，但很快就会变得难以管理。

这种模式在各个组织中重复出现：新的边缘情况需要修改提示，这有时能解决问题，但通常会导致其他地方出现退步。智能体缺乏从执行中学习或跨上下文传输知识的机制。上下文窗口因日益复杂的指令或矛盾而变得臃肿，导致智能体分心、困惑或无法对冲突信息进行推理。

过去我们普遍认为智能体在不同领域会因其提示和工具而显得非常不同。但底层的模型-智能体关系实际上比我们想象的更具普适性。这一认识提出了一种不同的模型：一个配备了专业能力库的通用智能体。

## **为什么智能体需要技能**

技能使我们无需改变架构即可迭代领域专业知识。

它们主要是声明性的，这意味着主题专家可以在不修改智能体逻辑的情况下贡献能力。安全团队可以将其合规工作流打包成一个技能。[数据工程团队](https://clickhouse.com/blog/agent-facing-analytics)可以编码其 ETL 最佳实践。这些贡献不需要触及智能体的核心系统提示或决策循环。

当智能体遇到新场景时，技能提供了清晰的责任边界。团队可以更新一个领域的技能，而不会冒着在另一个领域出现退步的风险。技能可以版本化，独立测试，并根据遥测数据进行改进，所有这些都无需系统提示工程的脆弱性。

技能支持渐进式加载，这会逐步引入资源以帮助解决上下文膨胀问题。任何使用智能体的人可能都经历过上下文窗口变得臃肿的情况，[2025 年的整个研究](https://www.anthropic.com/engineering/code-execution-with-mcp)表明，上下文窗口过载会导致意想不到的故障模式。

渐进式加载解决了这个问题：在运行时，智能体只看到技能元数据（名称和描述）。只有当智能体确定某个技能与当前任务相关时，才会加载完整内容。这意味着捆绑到技能中的上下文量实际上可以无限大，而不会损害智能体的推理能力。

## **一个真实世界的例子**

在构建 [clickhouse.build](https://clickhouse.com/blog/clickhouse-build-agentic-cli-accelerate-postgres-clickhouse-apps) 时，我们面临着完全相同的架构决策，它是一个智能体编码助手，帮助开发人员将分析工作负载从 [Postgres 迁移到 ClickHouse](https://thenewstack.io/postgres-clickhouse-the-oss-stack-to-handle-agentic-ai-scale/)。我们的命令行界面 (CLI) 最初提供了四个专门的智能体：一个扫描器，用于识别代码库中的分析查询；一个数据迁移器，用于设置 ClickPipes；一个代码迁移器，用于在保持向后兼容性的同时添加 ClickHouse 接口；以及一个 QA 智能体，用于验证更改。

范围被刻意限制在：Postgres 查询和 TypeScript 代码库。这种特异性使得智能体性能良好，但限制了它们的适用性。当 Anthropic 在 2025 年 10 月发布 Agent Skills 时，我们看到了一个机会，可以在不牺牲质量的情况下将范围扩展到狭窄的范围之外。

通过引入技能，我们现在可以支持其他在线事务处理 (OLTP) 源，例如 MySQL 和 [MongoDB](https://www.mongodb.com/cloud/atlas/?utm_content=inline+mention)，Python 和 Java 代码库，以及更灵活的 QA 工作流，而无需重写我们的核心智能体。语言客户端维护者可以为其领域（Golang、Java、Python）开发技能，而无需触及智能体编排逻辑。我们可以围绕特定技能构建评估并独立改进它们。

我们的智能体通过评估保持范围和质量，而技能则通过渐进式加载实现组织内领域专家的贡献并保护上下文窗口。

## **何时构建智能体或技能**

那么，什么时候应该构建智能体或技能呢？

当您需要以下情况时，构建一个智能体：

* 具有多步决策树的完整工作流编排。
* 跨复杂操作的状态管理。
* 通过系统评估进行质量控制。
* 防止滥用的范围边界。

当您需要以下情况时，构建一个技能：

* 可在不同上下文之间应用的、可重用的程序性知识。
* 非开发人员的领域专业知识贡献。
* 通过选择性加载来保护上下文窗口。
* 可以独立演进的能力。

许多现有的智能体——实际上是带有工具访问的结构化提示——很可能只需最少的更改即可成为技能。但有些用例确实需要完整的智能体所提供的控制、范围管理和可评估性。

## **智能体需要“技能执照”**

[智能体 AI](https://thenewstack.io/ai-agents-a-comprehensive-introduction-for-developers/) 的未来不是在智能体和技能之间做出选择。而是智能体在正确的时间配备正确的技能；如果你愿意，可以称之为拥有“技能执照”的智能体。智能体负责编排、维护范围并通过评估确保质量。技能则打包专业知识、保护上下文窗口并实现领域专家的贡献。

这种架构已经在重塑像 clickhouse.build 这样的生产系统，并且随着技能与 MCP 一同成为开放标准，它有望成为未来的默认前进方向。