<!--
title: 为什么仅靠AI无法完成大规模代码现代化
cover: https://cdn.thenewstack.io/media/2025/08/fab777fa-zhen-yao-sj4eawhc9ws-unsplash-scaled.jpg
summary: 本文探讨了AI在代码现代化中的作用，强调了AI的优势与不足，以及将AI与确定性自动化相结合的重要性。AI擅长辅助新功能开发，但大规模代码现代化更需要精确性。OpenRewrite等工具通过精确解析代码，实现安全、可扩展的代码转换。结合结构化代码数据，AI能更有效地进行代码分析和转换，使现代化成为一个持续的过程。
-->

本文探讨了AI在代码现代化中的作用，强调了AI的优势与不足，以及将AI与确定性自动化相结合的重要性。AI擅长辅助新功能开发，但大规模代码现代化更需要精确性。OpenRewrite等工具通过精确解析代码，实现安全、可扩展的代码转换。结合结构化代码数据，AI能更有效地进行代码分析和转换，使现代化成为一个持续的过程。

> 译自：[Why AI Alone Fails at Large-Scale Code Modernization](https://thenewstack.io/why-ai-alone-fails-at-large-scale-code-modernization/)
> 
> 作者：Olga Kundzich

现代软件团队面临着一个双重困境：既要更快地交付业务价值，又要维护老旧、复杂的代码库。对于高管来说，交付速度是衡量软件质量最直接的指标。当交付速度减慢时，这是一个质量正在表面之下受到侵蚀的信号。而这种减慢的结果是可以预见的——技术债务上升、认知负荷增加，以及缓慢而有风险的升级周期。

代码现代化一直很复杂。现在，随着 AI 进入开发者工作流程，问题出现了：它是增强了现代化，还是仅仅加速了现代化并增加了其风险？

在本文中，我将解释 AI 在哪些方面有所帮助，在哪些方面存在不足，以及为什么将其与确定性自动化相结合对于快速行动而不破坏一切至关重要。这不是一场人与机器的辩论。而是关于构建系统的，在这些系统中，每个部分都做它最擅长的事情——并且可以被信任去做。

## 代码现代化的瓶颈

大多数企业都背负着多年，有时甚至是数十年的技术债务。代码可能仍然可以工作，但很难更改。为什么？依赖项已过时，接口很脆弱，并且代码是为过时的版本编写的，例如 Java 6 或早期的 Spring Boot。这些基础现在限制了你发展的能力。

随着时间的推移，所有软件都倾向于变得越来越复杂。团队为了赶上截止日期而进行权衡。组织扩展，业务领域发展，并且支持工具变得过时。其中一些债务是内部的，但很多都是外部强加的。OSS 项目经常更新，供应商弃用 API，而你最终只能在充满 CVE 的过时框架上运行。

过去，我们将软件视为项目——构建一次并搁置。但今天的系统是组装的和相互依赖的。为了保持它们的功能，我们必须将它们视为产品：持续维护、定期更新和不断发展。

因此，开发人员现在将近一半的时间花在代码维护上。这包括处理升级、弃用、错误修复和[安全补丁——通常跨多个](https://thenewstack.io/linux-run-a-single-command-across-multiple-servers-with-ssh/)存储库，并且使用不一致的工具。更糟糕的是，这些更改中的许多根本没有实现。它们被记录、降低优先级或部分完成，留下一系列风险和不一致。

挑战不是缺乏开发人员的努力。而是我们构建的系统并非为频繁、安全和可扩展的变更而设计的。

## AI 可以（和不能）为现代化做什么

AI 正在被集成到软件开发生命周期的几乎每个部分。超过 90% 的[开发人员现在使用像 GitHub Copilot](https://thenewstack.io/a-developer-health-check-on-github-copilot-and-ai-assistants/)、Amazon Q 或其他 AI 助手这样的工具。这些工具很有用。它们有助于样板代码、自动完成、文档编制和导航不熟悉的库。

但仅靠 AI 不足以完成现代化工作。模型是概率性的。它们没有对你的构建系统、依赖关系图或代码格式规则的自然理解。它们不知道哪些更改可以安全地跨数百个存储库进行，或者这些更改可能如何破坏下游服务。

在受监管的行业或关键任务系统中，即使 AI 引入的一个小错误也可能产生过大的后果。这就是为什么人类开发人员仍然需要审查、测试和验证每个更改。结果是一个较慢的过程和有限的信任。这根本不是一个可以扩展到当今企业代码库需求的流程。

## 缺失的要素：确定性

AI 非常适合配对开发新功能。但对于大规模的代码现代化，精确性比创造性更重要。

这就是 [OpenRewrite](https://openrewrite.org/) 的用武之地。OpenRewrite 是一个开源的重构框架，旨在实现安全、可扩展和自动化的代码转换。它使用编译器精确的解析器分析源代码。它生成一个无损语义树 (Lossless Semantic Tree, LST)——一个结构化的表示，捕获代码的完整保真度，包括语法、语义、类型和格式。

OpenRewrite 的核心是配方：编码搜索和转换逻辑的确定性程序。这些配方可以被测试、版本化，并一致地应用于单个应用程序或数千个存储库。它们遵循明确定义的规则，以准确性和可重复性转换代码。

当你使用 OpenRewrite 时，你不是希望代码在事后能够编译。你正在使用一个深入理解代码并以结构和语义上正确的方式应用更改的框架。

随着最新[一代 AI 编码代理](https://thenewstack.io/better-llm-agent-quality-through-code-generation-and-rag/)（例如 Claude Code）的出现，创建自定义配方的成本已大大降低。曾经需要数小时才能编写的内容现在可以在几分钟内起草。

## 将 AI 扎根于你代码库的数据中

AI 模型本身并不了解你的代码库。它们看不到你的依赖关系图、构建系统或架构约定。它们基于概率而不是结构生成输出。要使用 AI 可靠地进行现代化，你需要的不只是一个提示。你需要以结构化的方式访问你自己的、编译器精确的代码数据。

例如，当 Moderne 推出我们的多存储库 AI 代理 Moddy 时，目标不是复制 [像 Copilot](https://thenewstack.io/testing-copilot-and-chatgpt-as-coding-assistants-what-we-found/) 或 Amazon Q 这样的[编码助手](https://thenewstack.io/testing-copilot-and-chatgpt-as-coding-assistants-what-we-found/)。相反，我们使 Moddy 能够利用每个客户代码库独有的丰富语义[数据来总结和推理](https://thenewstack.io/why-choose-a-nosql-database-there-are-many-great-reasons/)关于整个系统。

Moddy 的工作是协调大规模的现代化。它从一个提示开始——类似于“将所有 Spring 服务升级到版本 3”或“查找已弃用的加密用法”。从那里，它分析你代码库中的配方输出，识别需要更改的地方，并使用确定性配方将安全更改定向到源代码。

Moddy 通过 OpenRewrite 扎根于实际代码库的丰富性中（由此，配方成为可以提取结构化见解并执行准确转换的工具）。这种扎根很重要。语言模型是概率性的，虽然它们发展迅速，但这种限制不会消失。

随着 LLM 变得越来越商品化，长期价值不在于模型，而在于[数据和系统](https://thenewstack.io/cloud-native-computing-now-has-its-own-file-system-cubefs/) 为它们提供动力。它们的用处仅取决于给定的上下文。没有这种访问权限，AI 就像在黑暗中工作——与整个系统的完整结构脱节。

## 如何以正确的方式使用 AI 进行现代化

高管们被 AI 产品推介和采用最新编码助手的内部压力所淹没。但如果目标是提高[软件质量并加速工程生产力](https://thenewstack.io/tacos-the-key-to-remote-software-engineer-productivity/)，那么什么才是真正有效的？

这取决于你正在解决的现代化问题的类型：

* **使用生成式 AI** 进行平台重构和全新的[代码生成](https://thenewstack.io/ai-code-generation-6-faqs-for-developers/)。当逆向工程遗留系统、设计新组件或跨语言重写代码时，它尤其有用。（想想 COBOL 到 Java 或 Perl 到 Python）。
* **使用确定性重构自动化**，例如 OpenRewrite（以及建立在其上的平台）来现代化现有系统。这些最适合用于诸如删除已弃用的 API、升级框架或修复易受攻击的库之类的任务，目的是实现大规模的安全、可重复的更改。

并且无论用例如何，请记住[这些策略](https://www.moderne.ai/blog/large-scale-code-changes)：

* **让开发人员控制大规模变更。** 使用确定性工具和经过测试的配方来[建立对自动化的信任](https://thenewstack.io/ebooks/security/trust-no-one-and-automate-almost-everything-building-a-modern-zero-trust-strategy/)。当开发人员可以准确地看到正在更改的内容以及原因——跨一个或一千个存储库——他们就会获得批准和应用大规模转换的信心。
* **利用你最有价值的资产：结构化代码数据。** 准确、无损的代码表示形式可以解锁其他一切——可搜索性、自动化和安全现代化。结构化代码数据应被视为基础设施。
* **将 AI 与确定性执行相结合。** 让 AI 协助导航、模式发现、摘要和协调，但使用基于规则的配方来精确搜索、收集[源代码数据](https://thenewstack.io/use-your-data-in-llms-with-the-vector-database-you-already-have/) 并进行准确、可验证的更改。
* **使现代化成为持续的过程。** 不要将其视为一次性项目。将其构建到你的软件生命周期中，以便你的系统随着时间的推移安全地发展。

如果你希望 AI 成为现代化的朋友，请为其提供正确的工具、数据和边界，以创建在任何规模下都更安全、更清洁和更具适应性的代码。