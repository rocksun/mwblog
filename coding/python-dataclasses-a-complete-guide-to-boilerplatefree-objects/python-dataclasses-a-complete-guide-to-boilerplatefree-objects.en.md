A [dataclass](https://thenewstack.io/python-for-beginners-data-types/) in [Python](https://thenewstack.io/what-is-python/) is a way to store and organize related values in a structured, reusable way. But don’t we already have dictionaries, variables and classes to do that in Python? Why do we need a dataclass?

## Introduction

Here’s the difference:

* A variable holds a single value (person = “Jessica”).
* A dictionary holds multiple related values in a key-value format (`person = {"name": "Jessica", "age": 30, "email": "jessica@example.com"}`) and is good for ad hoc or single-use data.
* A class defines a blueprint for objects that can hold multiple values and perform different behaviors.
* A dataclass is a streamlined class designed to hold related values (like the person example in a dictionary) with minimal [boilerplate code](https://thenewstack.io/python-vibe-coding-tools/). Not to be confused with a dictionary, dataclasses are like regular classes. They’re blueprints for [Python objects](https://thenewstack.io/python-oop/).

At first glance, a dataclass might look a lot like a dictionary. A practical rule of thumb: Use a dictionary for a single object or when the structure is dynamic. Use a dataclass when you want to create multiple structured objects with the same fields.

Both a dataclass and a dictionary store key-value pairs. A dataclass is a typed object with dot-notation access, built-in methods like `__init__` and `__repr__` and easy comparison between instances.

Dataclasses can also look similar to Python classes. Use a dataclass over a regular Python class when you want to store related data rather than implement complex behaviors.

### Why Use Dataclasses

Before the introduction of dataclasses in Python’s 3.7 release, developers still needed to create objects with related data. The most popular choices for doing this were regular classes, dictionaries and namedtuples. But all three brought their own downsides. Classes required a lot of unnecessary, repetitive boilerplate code. Dictionaries couldn’t be autogenerated and didn’t have type hints. Namedtuples were immutable by default, had limited flexibility and adding default values and methods was labor-intensive.

So, Python developers created the solution: dataclasses.

Developers can write more declarative, maintainable code with dataclasses. They reduce boilerplate by autogenerating common methods. They enforce type hints. You can also add more advanced features with minimal syntax ([immutability](https://thenewstack.io/the-immutability-of-time-series-data/), ordering and efficient memory usage).

### Quick Start: Declaring Your First Dataclass

The `@dataclass` decorator marks a class as a dataclass, signaling that it will be used to store structured data.

```
from dataclasses import dataclass


@dataclass
class Point:
    x: int
    y: int


p = Point(3, 5)




print(p.x) 
print(p.y)  
print(p)    
```

Output:

3

5

Point(x=3, y=5)

### Automatic `__init__`, `__repr__` and `__eq__`

Dataclasses come with these methods built in (which is why you don’t see any code added for them).

* `__init__` sets up the object’s fields when you create it.
* `__repr__` gives a readable string representation of the object.
* `__eq__` lets you compare two objects by their values.

## Defining Fields and Types

In a dataclass, you define fields and their types by listing each attribute with a type annotation inside the class, like `x: int` or `name: str`.

### Required vs. Optional Fields

By default, dataclasses require all fields. You can add a value or a default value. A default value is a preset value that a field will use if you don’t provide one when creating the instance. A default value can be overridden when you create an instance.

```
from dataclasses import dataclass


@dataclass
class Person:
    name: str  # required value
    age: int = 30  # default value


# instance using the default age
person1 = Person(name="Jess")
 
# instance overriding the default age
person2 = Person(name="Dani", age=25)
print(person1) 
print(person2) 
```

Output:

Person(name=’Jess’, age=30)

Person(name=’Dani’, age=25)

You can also make a field optional:

```
from typing import Optional


@dataclass
class User:
    name: str
    age: Optional[int] = None
```

### Type Hints and Static Analysis

Dataclasses rely on type hints. Type hints are annotations that specify the expected data type of a variable, function parameter or return value in Python. They look like this in the code `name: str` or `age: int`. Type hints help catch errors early through static analysis. [Static analysis](https://thenewstack.io/how-static-analysis-can-save-your-software/) uses tools like `mypy` and [IDEs](https://thenewstack.io/best-open-source-ides/) to warn you if you try to assign a value of the wrong type. This improves code safety and readability.

### Default Values and `default_factory`

In Python, using a mutable object (like a list or dictionary) as a default value can cause unexpected behavior because all instances share the same object. This is called the mutable default trap. To prevent this, dataclasses provide `default_factory`, which creates a new object for each instance:

```
from dataclasses import dataclass, field


@dataclass
class Team:
    members: list = field(default_factory=list)  # each instance gets its own list


team1 = Team()
team2 = Team()


# add member to the first team
team1.members.append("Leslie")


# print members of each team
print("team1 members:", team1.members)  # Output: ['Alice']
print("team2 members:", team2.members)  # Output: [] — separate list


# show different objects
print("team1 list id:", id(team1.members))
print("team2 list id:", id(team2.members))
```

Output:

team1 members: [‘Leslie’]

team2 members: []

team1 list id: 4425609792

team2 list id: 4419089664

## Controlling Generated Methods

We know dataclasses automatically create the methods `__init__`, `__repr__` and `__eq__`. You can also customize your class and control which methods are generated and how they behave.

### Comparisons With `order=True`

`@dataclass(order=True)` generates comparison methods like `<`, `<=`, `>` and `>=` based on the order of fields. This allows you to compare and sort instances easily. This is useful for lists of objects or prioritization.

```
from dataclasses import dataclass


@dataclass(order=True)
class Item:
    price: float
    name: str


item1 = Item(10.99, "Notebook")
item2 = Item(5.49, "Pen")
item3 = Item(7.25, "Pencil")


# compare instances
print(item1 > item2)  
print(item2 < item3)   


# sort a list of items
items = [item1, item2, item3]
items.sort()
print(items)
```

Output:

True

True

[Item(price=5.49, name=’Pen’), Item(price=7.25, name=’Pencil’), Item(price=10.99, name=’Notebook’)]

### Hashability and `frozen=True`

`frozen=True` makes dataclass instances immutable, meaning their fields cannot be changed after creation. It also makes them hashable, so they can be used as dictionary keys or stored in sets. This is important for creating safe, constant objects that rely on stable values.

```
from dataclasses import dataclass


@dataclass(frozen=True)
class Currency:
    code: str
    symbol: str


usd = Currency("USD", "$")
eur = Currency("EUR", "€")


# attempting to modify a field will raise an error
try:
    usd.symbol = "US$"  
except AttributeError as e:
    print(e) 


# they can be used as dictionary keys
currency_rates = {
    usd: 1.0,
    eur: 0.92
}


print(currency_rates[usd])
print(currency_rates[eur]) 
```

Output:

cannot assign to field ‘symbol’

1.0

0.92

### Customizing `__post_init__`

The `__post_init__` method runs after the dataclass is initialized, letting you enforce constraints, validate values or perform extra setup. It ensures data integrity without manually writing an initializer.

```
from dataclasses import dataclass


@dataclass
class Product:
    name: str
    price: float


    def __post_init__(self):
        if self.price < 0:
            raise ValueError("Price must be non-negative")


product1 = Product("Laptop", 1200.00)
print(product1)  


# attempt to create a product with a negative price
try:
    product2 = Product("Headphones", -50.00)
except ValueError as e:
    print(e)  
```

Output:

Product(name=’Laptop’, price=1200.0)

Price must be non-negative

### Advanced Features

Dataclasses offer several more advanced features to improve memory efficiency, code clarity and integration with modern Python features.

### Slots Support for Memory Efficiency

In Python 3.10+, you can use `slots=True` to tell the dataclass to predefine its attributes, which reduces memory usage and speeds up attribute access.

### Keyword-Only Fields (`kw_only=True`)

Using `kw_only=True` forces all fields to be passed as keyword arguments, improving clarity and preventing mistakes from passing values in the wrong order.

### Pattern Matching With Dataclasses

You can match objects based on their field (released in 3.10) because dataclasses integrate seamlessly with structural pattern matching.

## Inheritance and Mixins

Inheritance and mixins both allow classes to reuse or extend behavior and functionality from other classes, making code more modular and easier to maintain.

### Extending Dataclasses (Inheritance)

If you’ve worked with classes before, this one will be familiar. Dataclasses can inherit fields and behaviors from other classes, similar to parent and child classes. In the example below, the child class DiscountedProduct automatically inherits name and price from Product, so you only need to define what’s new (in this case, it’s the discount).

```
from dataclasses import dataclass


@dataclass
class Product:
    name: str
    price: float


@dataclass
class DiscountedProduct(Product):
    discount: float


dp = DiscountedProduct("Laptop", 1200.0, 150.0)
print(dp)
```

Output:

DiscountedProduct(name=’Laptop’, price=1200.0, discount=150.0)

### Mixing Regular and Dataclass Bases

You can combine dataclasses with regular classes to “mix in” additional behaviors and methods. This approach lets you combine the convenience of dataclasses with additional functionality. If you do decide to mix, you need to be aware of your method resolution order (MRO). The MRO determines which method is used if multiple base classes define the same method.

```
class Logger:
    def log(self, message):
        print(f"LOG: {message}")


@dataclass
class Event(Logger):
    name: str
    time: str


e = Event("Meeting", "10:00")
e.log(f"{e.name} at {e.time}") 
```

Output:

LOG: Meeting at 10:00

## Performance and Memory Considerations

Dataclasses are convenient, but they do use more memory per instance because each object stores its attributes in a dynamic `__dict__`. `__dict__` is a Python dictionary that maps attribute names to their values. The `__dict__`  allows dynamic attribute assignment and modification (add, change or delete attributes at runtime). The flexibility is convenient but requires extra memory to store the dictionary structure. The overhead comes from Python needing to maintain a dynamic mapping for each instance’s attributes. This makes dataclasses use more memory than fixed storage like tuples or slots.

There is a lighter solution for applications in need of thousands or millions of dataclass objects. In these instances, you can use `slots=True` to predefine the fields. This eliminates the `__dict__` and reduces memory usage while speeding up attribute access.

Why not use `slots=True` for all applications? `slots=True` isn’t a catchall improvement; it’s specifically useful in applications where memory is a concern. When only working with a small number of objects, the memory and speed improvement will be negligible. You can’t add new attributes dynamically; all fields must be predefined, which can be restrictive. It also complicates class inheritance, especially if you mix slotted and nonslotted classes.

## Common Pitfalls and Limitations

### Mutable Defaults

Dataclasses share defaults across all instances. This means that using mutable objects as default values can lead to unexpected behavior. To avoid unexpected behavior, use `default_factory` to create a new object for each instance. `default_factory` ensures each instance has its own independent object.

### Recursive Types

Recursive dataclasses work, but they make type hints and static analysis tricky and error-prone. In recursion, dataclasses may have fields that reference their own type, like linked lists and trees. Python type hints don’t automatically resolve recursive types at runtime. This makes static analysis challenging in this instance. You can use string annotations or `from __future__ import annotations` to work around this.

```
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional


@dataclass
class Node:
    value: int
    next: Optional[Node] = None 
```

## Real-World Use Cases

Let’s see some dataclasses in the wild.

### Configuration Objects

Dataclasses are ideal for representing structured settings in an application. Instead of a dictionary with arbitrary keys, you can define a dataclass with specific fields, type hints and defaults, which improves readability, safety and maintainability.

```
from dataclasses import dataclass


@dataclass
class AppConfig:
    host: str = "localhost"
    port: int = 8080
    debug: bool = False


config = AppConfig(port=5000, debug=True)
print(config) 
```

Output:

AppConfig(host=’localhost’, port=5000, debug=True)

### Lightweight DTOs in APIs

Data transfer objects (DTOs) are request and response payloads in web services. And when you use a dataclass to create them, they provide a clear, structured format for data without writing verbose classes. DTOs built with dataclasses integrate easily with serialization libraries.

```
from dataclasses import dataclass


@dataclass
class UserDTO:
    id: int
    name: str
    email: str


# web API
request_payload = UserDTO(id=1, name="Jess", email="jess@example.com")
print(request_payload)
```

Output:

UserDTO(id=1, name=’Jess’, email=’jess@example.com’)

### Immutable Domain Entities

Dataclasses with `frozen=True` make it easy to define immutable domain entities in systems where immutability is important, like Domain-Driven Design (DDD). This prevents bugs and enforces business logic because objects `frozen=True` can’t be changed after it’s created.

```
from dataclasses import dataclass


@dataclass(frozen=True)
class Currency:
    code: str
    symbol: str


usd = Currency("USD", "$")
eur = Currency("EUR", "€")


# attempt to modify a frozen field
try:
    usd.code = "US Dollar"  
except AttributeError as e:
    print(e)  
```

Output:

cannot assign to field ‘code’

## Testing and Debugging Dataclasses

Dataclasses are a unique class, but many of the [debugging](https://thenewstack.io/master-the-art-of-python-debugging-with-these-tips/) tips are in line with ones that you’d see with any other Python tool.

* Validate early: `__post_init__` catches invalid values as soon as you create the object.
* Print easily: `__repr__` shows all fields so you can see what’s inside an object.
* Be careful with mutable values, use frozen classes (`frozen=True`) when necessary.

## Conclusion

Like many tools in Python, dataclasses may seem complicated, but with a little practice, they’ll become more manageable to work with. They’re a useful tool for working with multiple instances of organized data. Once you get comfortable with them, you’ll notice how much cleaner and more readable your code becomes. They also help prevent common errors by providing structure, type hints and built-in methods for comparison and representation.

[YOUTUBE.COM/THENEWSTACK

Tech moves fast, don't miss an episode. Subscribe to our YouTube
channel to stream all our podcasts, interviews, demos, and more.

SUBSCRIBE](https://youtube.com/thenewstack?sub_confirmation=1)

Group
Created with Sketch.

[![](https://thenewstack.io/wp-content/uploads/2023/04/d55571c0-cropped-b09ca100-image1-600x600.jpg)

Jessica Wachtel is a developer marketing writer at InfluxData where she creates content that helps make the world of time series data more understandable and accessible. Jessica has a background in software development and technical journalism.

Read more from Jessica Wachtel](https://thenewstack.io/author/jessica-wachtel/)