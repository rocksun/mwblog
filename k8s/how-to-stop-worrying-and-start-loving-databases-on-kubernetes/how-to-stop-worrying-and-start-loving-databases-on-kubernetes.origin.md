# How To Stop Worrying and Start Loving Databases on Kubernetes
![Featued image for: How To Stop Worrying and Start Loving Databases on Kubernetes](https://cdn.thenewstack.io/media/2024/10/6edf426e-love-databases-on-kubernetes-1024x576.jpg)
Kubernetes (K8s) has undeniably transformed deployment and management for applications. It is a cornerstone of cloud native architecture. Modern DevOps teams use [Kubernetes](https://roadmap.sh/kubernetes) for orchestration of high-availability pods, multizone failover and distribution of load across data centers for applications.

Yet, when it comes to running [ databases on Kubernetes](https://thenewstack.io/how-to-run-databases-in-kubernetes/), many teams still hesitate. The skepticism isn’t unfounded; Kubernetes was once considered the wrong choice for stateful applications due to concerns about storage persistence, data integrity and operational complexity. Databases on Kubernetes were looked at similarly to

[BASE jumping](https://en.wikipedia.org/wiki/BASE_jumping), but for DevOps.
Luckily, times have changed. Kubernetes has improved. The Kubernetes ecosystem has grown. Once seen as daring, stateful [Kubernetes Operators](https://thenewstack.io/kubernetes-when-to-use-and-when-to-avoid-the-operator-pattern/) are now mature and robust. However, all implementations are not equal. So, let’s delve into the critical considerations for running a database on Kubernetes.

## Rise of the Operator Pattern
Kubernetes uses the term “Operator Pattern” to define an algorithm for managing stateful workloads. In implementations it may be referred to as “Operator” or “Kubernetes Operator” or “Kubernetes database operator.” Simply put, a Kubernetes Operator is a codebase that encapsulates operational knowledge into automation tasks that manage stateful deployments on Kubernetes. The automation tasks include initialization of high availability, running backups, restore backups, health checks and failover.

A GitHub search will return multiple Kubernetes Operators for any database. With choices between multiple operators and implementation of Kubernetes, any two teams running databases on Kubernetes may have significant differences in their happiness.

The best Kubernetes Operators have the longest running time-in-production on stressed environments. The experience gained over time cannot be understated. Experience is how the daring found edge cases and wrote code that operationalizes it. Finding a new edge case on a Kubernetes Operator in a production deployment will shake confidence in the system. Thus, look for a Kubernetes Operator who can handle the nuances of the database and has a strong record of time in production.

## Essentials of Database Management on Kubernetes
Starting a database in a container is simple. Operating a production database ensuring data integrity, availability and performance requires a checklist. Consider the following when choosing a Kubernetes Operator:

**Backups:**Data is the lifeblood of any organization. Regular and reliable backups are non-negotiable. In a Kubernetes environment, integrating backup solutions with object storage services, like[Amazon](https://aws.amazon.com/?utm_content=inline+mention)S3, can offer scalable and durable storage options. Automated backup schedules, encryption and restoration processes are features to look for in a robust backup strategy.**Monitoring:**Visibility into a database’s performance is crucial for preempting issues. Kubernetes provides tools like Prometheus and Grafana for monitoring. Additionally, the database should expose its own metrics that are meaningful and actionable. These metrics should cover aspects like query performance, resource utilization and latency.**Disaster recovery:**Disaster recovery planning ensures that you have a plan for restoring services in the event of catastrophic failures. Kubernetes’ ability to manage workloads across clusters can be leveraged for effective disaster recovery strategies. Organizations should routinely test recovery procedures.**High availability**: Downtime is costly (financially and reputationally). Kubernetes shines when deploying high-availability environments, thus preventing single points of failure. Kubernetes supports this through StatefulSets and ReplicaSets, enabling the running of multiple instances of a database that can take over seamlessly if one fails.**Connection scaling**: As a user base grows, so does the demand on database connections. Kubernetes excels at scaling stateless applications, but databases require thoughtful connection-scaling strategies. Connection pooling and horizontal scaling of read replicas are a tool to mitigate increasing loads without degrading performance.
## Cloud Native Considerations
This checklist has been around as long as databases themselves. Framing the checklist with respect to cloud native principles changes the thought model a bit. Complexity is introduced, but that also creates opportunities.

**Disk storage solutions:**Spend time to build an understanding of Kubernetes’[storage architecture](https://thenewstack.io/storage/). If choices to configure compute are linear, then choices to configure storage are a matrix. StatefulSets manage persistent volumes, but selecting the right storage class affects performance and availability. Additional considerations include factors like input/output per second (IOPS), latency and redundancy when choosing storage solutions for your database. When running databases on Kubernetes, it’s not unrealistic to spend the most time planning for storage needs.**Backups and object storage:**While the “storage” above refers to performance for the files in active use by a database, object storage is a place for backups and transaction logs. Integrating backups with object storage services decreases costs and empowers data durability. Production use requires the Kubernetes database operators to support seamless integration with modern object storage.**Ease of use and scalability:**Kubernetes’ strength is scaling applications effortlessly. Modern Kubernetes database operators enable easy scaling up (vertical scaling), scaling out (horizontal scaling) and scaling down (during low-traffic periods). Automation through Kubernetes Operators simplifies these events into standardized configurations and API calls.**Upgrades and maintenance:**Running updates and maintenance should feel routine. Kubernetes Operators facilitate rolling updates, which minimizes downtime during upgrades. Ease of automation reduces the costs of testing using canary deployments. These tests reduce risks traditionally associated with updating critical database systems.
## Running Databases on Kubernetes Is a Known Path
Running a database on Kubernetes should not be a source of anxiety — if it is, go a different route. The right tools and implementations create a robust and resilient data layer for your applications.

The good news is the path is a known path, and it has been paved with code that points the way. By embarking on this journey with mature Operators, teams will build on the success of prior experience. The goal is clear: let a Kubernetes Operator take care of the databases; deliver value to users through innovative applications.

*Interested in learning more about Kubernetes Operators? Stop by the Crunchy Data booth P8 at KubeCon + CloudNativeCon North America Nov. 12 – 15 to speak with an expert or see a demo.*
*To learn more about Kubernetes and the cloud native ecosystem, join us at **KubeCon + CloudNativeCon North America**, in Salt Lake City, Utah, on Nov. 12-15, 2024.*
[
YOUTUBE.COM/THENEWSTACK
Tech moves fast, don't miss an episode. Subscribe to our YouTube
channel to stream all our podcasts, interviews, demos, and more.
](https://youtube.com/thenewstack?sub_confirmation=1)