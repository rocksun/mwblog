# Advantages of storing configuration in container registries rather than git
Storing configuration files and packages in git is pretty common. Sometimes they are committed alongside source code, sometimes they are stored alongside other configuration packages, and sometimes they live in their own repositories.

Storing deployment configuration with source code initially seems convenient, but leads to a number of challenges at deployment time, such as [coupling permissions and git triggers](https://codefresh.io/blog/argo-cd-best-practices/) for source and configuration, conflicting branching and promotion strategies across environments, orchestrating multi-component deployments, and so on. When storing configuration on its own, the toil of performing edits to configuration in git becomes more obvious: clone, branch, edit, add, commit, push, create change request, review, merge, tag.

Either way, in order to deploy a bundle of configuration files, such as with helm, it is sometimes copied to an object store, artifact registry, or container registry, typically from a CI process, but [automatic builds](https://docs.docker.com/docker-hub/builds/) or [mirroring](https://cloud.google.com/artifact-registry/docs/repositories/remote-overview#user-defined-upstreams) might also be possible in some cases. Such repositories meet scalability, performance, reliability, network access, security, and data residency requirements of production deployment systems, and especially useful for certain scenarios, such as [edge deployments](https://medium.com/@briankgrant/is-gitops-actually-useful-a1c851ba99d8). Images can be also cached, replicated, and distributed peer to peer.

If we’re going to push configuration into such repositories, why not just store it there in the first place? Images can model both [drafts (changes) and revisions](https://github.com/kptdev/kpt/blob/main/docs/design-docs/07-package-orchestration.md), and can be versioned and referenced similarly to git commits, with both immutable content digests and user-defined tags.

There’s a [broader trend](https://blog.andyserver.com/2024/03/kubecon-eu-2024-a-model-conference/) towards using container registries for universal [artifact storage](https://github.com/oras-project/oras). After all, container images are bundles of files, essentially. (It would have been great to have been able to [mount images as volumes into running containers in Kubernetes](https://github.com/kubernetes/kubernetes/issues/831), but that’s another issue.) [OCI](https://opencontainers.org/) registries are already supported by many tools, including [helm](https://helm.sh/docs/topics/registries/), [Config Sync](https://cloud.google.com/blog/products/containers-kubernetes/gitops-with-oci-artifacts-and-config-sync), [Flux](https://fluxcd.io/flux/cheatsheets/oci-artifacts/), [timoni](https://timoni.sh/#oci-artifacts), [Crossplane](https://docs.crossplane.io/latest/concepts/packages/), and [Tekton](https://github.com/tektoncd/community/blob/main/teps/0005-tekton-oci-bundles.md).

One reason is their ubiquity. Teams deploying to container runtimes already need to have access to a repository. Additionally, registry APIs and authentication methods are [more standardized](https://github.com/opencontainers/distribution-spec) than either object stores or git providers. This makes them easier to integrate with. Because images are more granular, focused bundles of files than [typical git repositories](https://medium.com/@briankgrant/monorepos-vs-many-repos-is-there-a-good-answer-9bac102971da) containing configuration packages and they can be [annotated](https://github.com/opencontainers/image-spec/blob/main/annotations.md) with information about their contents, configuration packages in container registries are easier to discover, list, and filter than ones residing in subdirectories of git repositories.

Container registries also support a number of management and governance features that are beneficial to deployable assets like configuration bundles. For example:

- rich metadata: Some registries support a
[variety of metadata](https://cloud.google.com/artifact-analysis/docs/metadata-management-overview), including provenance,[SBOMs](https://www.cisa.gov/sbom), attestations, deployment events, and more. - signatures: Images can be
[signed](https://www.sigstore.dev/)to ensure authenticity. - policy enforcement: A variety of image properties can be verified and required.
Furthermore, in the future, once we’re automating most configuration generation and changes, the configuration becomes a generated artifact. In that scenario, git loses much of its value since users would not be interacting with it directly. This applies to the [rendered manifest pattern](https://akuity.io/blog/the-rendered-manifests-pattern/) also.

Since there are a number of advantages, hopefully we’ll see more users using container images as the authoritative source for their configuration files and packages going forward, and [more tools](https://github.com/hashicorp/go-getter/issues/271) supporting it.

That said, once we’re automating most configuration changes, we really should rethink the configuration toolchain from first principles and whether we really want to be in this corner we’ve painted ourselves into. Pushing configuration to a more highly available storage system doesn’t improve the change-control process at all, for instance.

Do you treat configuration modules, templates, or packages similar to other deployable build artifacts, or directly apply them from their sources of truth? Do you encounter challenges with pulling directly from your git provider in [GitOps controllers](/is-gitops-actually-useful-a1c851ba99d8)? Do you find it challenging to [keep track of all of the git repos](/the-insidious-problem-of-configuration-sprawl-66360fce6ca3) containing deployable configurations? Do you find it challenging to [keep those repos up to date](/making-mass-changes-to-infrastructure-as-code-b1edea2f7c48)? Have you tried storing configuration in container images? Is it any better than alternatives? Does that still seem unnecessarily cumbersome?

Feel free to reply here, or send me a message on [LinkedIn](https://www.linkedin.com/in/bgrant0607/) or [X/Twitter](https://x.com/bgrant0607), where I plan to crosspost this.

If you found this interesting, you may be interested in other posts in my [Infrastructure as Code and Declarative Configuration series](https://medium.com/@bgrant0607/list/infrastructure-as-code-and-declarative-configuration-8c441ae74836).