# 知道 liveness 和 readiness 探针的作用吗？

标准答案：
: 检测存活性的是 liveness 探针，检测就绪状态的是 readiness 探针。

当然**不是**啦，我不强调估计真有人信。百度上可以搜到许多抄来抄去的烂文章，感觉也不全是采集站的作品，本性纯良的小朋友确实挺多的。上面这段是好多小朋友的回答，信息量确实乏善可陈。

其实[官网](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)一上来就说的很清楚：

> kubelet 使用存活探针来确定什么时候要重启容器。 例如，存活探针可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。
>
> kubelet 使用就绪探针可以知道容器何时准备好接受请求流量，当一个 Pod 内的所有容器都就绪时，才能认为该 Pod 就绪。 这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。 若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。

这个中文翻译存在一些瑕疵，[英文文档](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)表达的更精确。我这也是废话，能看英文的同学基本应该早就会了这个知识点。

那还有个原因，很多人不懂这个探针的作用，是根本没搞清楚探的对象是谁？上述文档中确实存在有点容易引起歧义的叙述，让人感觉存活探针是探测应用，而就绪探针是为了探测容器。这个情况还真真存在，之前我问二者的区别时，真有人这么回答。这其实不应该，因为你继续看，就知道二者探测的都是容器中的应用。

按照官网文档的说法，最表层的理解应该是当存活探针检测失败时，kubelet 会重启容器。而就绪探针探测失败时，则服务不会向这个 Pod 转发请求流量。但是更深层面的认识是，如果是应用自身无法解决的问题，则存活探针应该报告错误，这样就可以触发重启，从而解决问题。如果是应用能够自行恢复的临时问题，则只需要让就绪探针报告错误，流量就不会转发到这个 Pod，同时也可以避免没有必要的重启，从而避免了[级联效应](https://www.bilibili.com/video/BV13Q4y1K7FU/?spm_id_from=333.999.0.0)。是不是格局打开了？

可能有同学问了，老师你太厉害了，我怎么想不到呢？这位同学一看就是可造之材。答案其实也很明了。首先，一定要理解所学东西的作用。人家作者开发出来一个功能，肯定是为了达到某个目的，这个目的知道了，才算是真正理解这个功能。其次，当然是要提高姿势水平了。天下没有新鲜事，许多功能其实都是实践中形成了理论，然后推而广之。级联效应也不是什么新发明，这是[稳定性的反模式](https://insights.thoughtworks.cn/chaos-engineering-quick-start/)的一部分，有兴趣的也可以看看我的[稳定性模式于反模式的视频](https://space.bilibili.com/23084774/channel/seriesdetail?sid=1420876)。

