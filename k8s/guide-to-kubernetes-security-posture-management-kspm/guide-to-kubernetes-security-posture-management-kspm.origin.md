# Guide to Kubernetes Security Posture Management (KSPM)
![Featued image for: Guide to Kubernetes Security Posture Management (KSPM)](https://cdn.thenewstack.io/media/2024/05/c5e5ae23-key-8707466_1280-1024x574.jpg)
An assessment practice, Kubernetes Security Posture Management (
[KSPM](https://thenewstack.io/detect-and-mitigate-common-attack-techniques-for-containers/)) offers a robust framework for protecting against common attack vectors, responding to incidents, and ensuring a deep layer of defense through a defense-in-depth strategy. But how do you harden your Kubernetes clusters, enhance incident response capabilities and implement defense-in-depth measures?
**Fundamental Hardening Techniques**
KSPM starts by implementing “cyber hygiene” practices to defend your cluster against common attack vectors. This includes securing the Kubernetes control plane to prevent potential attacks. Measures like limiting external access, securing authentication, and using Role-Based Access Control (
[RBAC](https://thenewstack.io/7-expert-strategies-for-managing-rbac-on-openshift/)) are crucial first steps.
**Common Kubernetes Misconfigurations and How to Avoid Them**
Bad security posture impacts your ability to respond to new and emerging threats because of extra “strain” on your security capabilities caused by misconfigurations, gaps in tooling, or inadequate training. Security Posture Management can be applied to different areas of your organization’s technical landscape, including the Cloud Security Posture Management (
[CSPM](https://thenewstack.io/microsoft-bolsters-cloud-security-with-devops-cspm-coverage/)) and KSPM.
Here are suggestions for improving your posture, following a “crawl, walk, run” maturity model.
**Secure the Control Plane and API Access**
An often-overlooked Kubernetes security measure is securing the control plane, which is typically exposed in managed
[Kubernetes](https://thenewstack.io/Kubernetes/) services. Blocking external access to the control plane and API instantly boosts security against exploits targeting control plane vulnerabilities. Attackers then must either exploit exposed workloads or compromise internal control plane access, both of which require additional security measures. Securing the control plane is like locking your door — a determined thief may find a way in, but most won’t bother. You’ll still need access to your cluster, so you’ll need a way in while the control plane is offline. Here are the options: **Crawl:**Use a Bastion Host — an internet-accessible server in the same private network as your cluster but not joined as a node — as the gateway to your cluster. Ideally, you spin the bastion up when needed, then shut it down when you don’t to minimize its exposure, too. **Walk:**Use a Cloud provider service to facilitate secure connections. For example, AWS customers can use System Manager (SSM) to connect to nodes in the cluster without a public IP. This uses AWS’s IAM service to handle authentication and authorization. **Run:**Use an identity-aware proxy to broker access to the nodes in your network without making them available to the public internet. This can then tie into your existing identity provider and authorization system. **Strengthen the Kubernetes Authentication Process**
Once connected to your cluster, the next step is authenticating to assume a role. Kubernetes delegates authentication to external systems. Since Kubernetes doesn’t revoke authentication material, providers must set expiration, placing the onus of authentication security on your chosen external system.
After authentication, authorization is handled natively via Kubernetes RBAC. Kubernetes accepts x509 certificates and bearer tokens as valid authentication materials, giving you a few ways of generating and securing the necessary materials.
**Crawl:**If you’re using a managed Kubernetes service, your cloud provider may have a way of translating its native authentication protocol to a bearer token for Kubernetes authentication. This moves the problem back one step: now you need to protect authentication to your cloud provider (ideally using SSO from your existing IdP). **Walk:**Kubernetes supports OIDC for authentication, so if your IdP is an OIDC provider, you can use it to authenticate directly to the cluster (rather than using it to authenticate to the cloud provider and then using the cloud provider to authenticate to the cluster). **Run:**Zero Trust architectures broker access through identity-aware proxies. If you have configured your cluster nodes to only be accessible via Zero Trust, you’ve already established an identity when you connect to those nodes. You can use the same Zero Trust architecture to establish your identity for the cluster itself. **Enforce the Principle of Least Privilege through RBAC**
RBAC enforces the Principle of Least Privilege, meaning roles and high-privilege groups should have limited assignments and usage. Powerful roles (like admin) and groups (such as system:masters) should be restricted to specific users and used only when essential. System:masters should be reserved for emergencies when other cluster access methods are unavailable.
**Crawl:**Restrict privileged access to a group. This is the essence of RBAC; privileged access is limited to only those who need it. **Walk:**Make it a regular practice for members of the privileged access group to use a lower privilege account except when they need higher ones. This requires them to reauthenticate with a more privileged account. This brings two advantages: first, an added layer of protection for privileged access and, second, a more clear audit trail for all privileged activities. **Run:**Restrict privileged access to break-glass only: this pairs especially nicely with a GitOps deployment and management system (see next item). In essence, don’t give out access to admin or otherwise privileged accounts — keep the credentials for them in a secure place only to be used in a break-glass scenario. **Use GitOps to Deploy and Manage Clusters**
GitOps manages all cluster changes via Configuration as Code (CaC) in Git, eliminating manual cluster modifications. This approach aligns with the Principle of Least Privilege and offers benefits beyond security.
[GitOps](https://thenewstack.io/does-the-gitops-emperor-have-no-clothes/) ensures deployment predictability, stability and admin awareness of the cluster’s state, preventing configuration drift and maintaining consistency across test and production clusters. Additionally, it reduces the number of users with write access, enhancing security. **Crawl:**When your pipelines are approved and you merge to main, run a simple “helm upgrade” job. This is easy to implement, but requires giving your continuous integration and deployment ( [CI/CD](https://thenewstack.io/ci-cd/)) system at least one fairly privileged account in your cluster (possibly more, depending on how your CaC is organized). **Walk:**Use a GitOps Operator. Instead of pushing out changes directly from your CI/CD, this approach pulls changes in using an operator in the cluster that’s watching your git repos for changes. Now, instead of granting your CI tooling credentials for your cluster, you grant the single operator already running in your cluster read access to your relevant CaC repos. **Run:**Once your GitOps workflow is going smoothly, there shouldn’t be a need for user roles in your production clusters that can make manual changes. Dev, test and (possibly) staging clusters should probably never reach this level of “maturity,” as part of the point of those is trying things out. **Prevent Container Escapes by Limiting Privileges**
The Kubernetes lifecycle involves workloads running as containers, which are processed on a host with privileges based on the host user and the container’s declared user. To limit privileges, run containers with non-root users on the host and within the container. Focusing on non-root users for containers is crucial, as it minimizes opportunities for container escapes and makes them more challenging.
**Crawl:**Audit your containers. The first step is to know what you have running in a privileged mode. Then you can begin removing privileges from workloads that don’t need it. **Walk:**Start enforcing restrictions on privileged containers with an admissions controller rule to prevent containers running in privileged mode from running at all. **Run:**Check privileges during CI/CD. Evaluate containers for the use of root users during your CI/CD pipelines so developers can fix the permissions before attempting a deployment.
The many misconfigurations possible in Kubernetes highlight the importance of KSPM in drastically reducing your attack surface. Since Kubernetes spans both the build as well as runtime, any discussion of KSPM must include incident response.
**Enhanced Incident Response**
Moving beyond hardening, KSPM focuses on incident response in Kubernetes clusters by using Kubernetes mechanisms and external tools. This includes implementing cluster logging and real-time monitoring to detect and analyze anomalous activities for potential security breaches. An admission controller enforces security policies during deployment, following best practices like OWASP Top 10 for Kubernetes to prevent non-compliant or malicious resource deployment and enhance proactive defense.
**Tying KSPM to Incident Response**
How do you handle incidents in your clusters? Identifying and containing them is crucial for security responsiveness. This builds upon basic cyber hygiene practices. For serious incidents, you might need to use break-glass roles from Kubernetes RBAC. Other security measures in your Kubernetes posture enhance incident detection and response capabilities.
**Advanced Misconfiguration Remediation for Incident Response** **Enable and Use Cluster Logging**
Kubernetes logging serves dual purposes: supporting
[DevOps](https://thenewstack.io/devops/) by providing valuable feedback for bug fixes and new releases and aiding SRE teams in diagnosing outages and collaborating with developers. For security, logs are essential for tracing and assessing incidents. Kubernetes collects default system and container logs locally, but aggregating them for easier monitoring and searching is ideal. **Crawl:**Use the Kubernetes Default. Kubernetes by default collects many important logs on the local file system of your nodes. You can search those logs using kubectl logs commands. **Walk:**Deploy a logging agent, which allows you to (a) collect more logs, (b) sort and filter those logs based on your priorities and (c) aggregate logs into a common storage archive for searching and analysis. **Run:**If you are collecting logs into a single storage archive, the next step is to push them into a [Security Information and Event Management](https://thenewstack.io/security/)(SIEM) solution. This will allow you to organize, index and search across them more easily. **Have Real-Time Monitoring in Your Cluster**
Human log analysis is crucial for retrospectively reviewing security incidents. However, real-time monitoring and correlation are essential for detecting incidents initially. While manual methods like SIEM solutions with dashboards and alerts can be effective, they require significant time and effort to extract relevant data. For a responsive security approach, automation is key to monitor, analyze and respond to events promptly as they occur.
**Crawl:**The first step is deploying a detection and response tool that’s able to analyze activity in your cluster and make real-time judgments on what it sees. Just deploying the tool with its default detection posture is a win. **Walk:**Start tuning the detections based on your cluster. Any real-time detection and response tooling has to make judgment calls based on the presence of certain known factors. If your cluster has things like internal apps the tool has never seen before, lift-and-shift legacy software that might not act in the most Kubernetes “normal” way or other features that could be “unusual,” you’re going to get a lot of false positives. The next step is tuning the detections based on your actual cluster so you have a better signal-to-noise ratio. **Run:**Actively monitor with real-time KSPM. Detection and response tooling is usually configured to generate an alert whenever it finds something it thinks is out of the ordinary. The next step is to actively monitor those alerts and whatever other telemetry the tooling is giving you to reduce your response time as much as possible. Ensure the misconfigurations you are seeing in Kubernetes are tied in real-time to the Kubernetes lifecycle versus polling intervals so you have full historical context. **Use an Admission Controller for Container Runtime Security**
Not all KSPM solutions offer admission control, yet it’s crucial for security in Kubernetes deployments. Following the
[OWASP Top 10 for Kubernetes](https://ksoc.com/blog/detailing-the-owasp-top-10-for-kubernetes) helps define essential policies. An admissions controller enforces these policies during deployment, rejecting non-conforming objects. It can block root-permission containers, verify artifact signatures or reject “known-bad” images. Some controllers can also check and remediate existing cluster resources for compliance. This responsiveness blocks non-compliant resources and allows for rule adjustments, strengthening security over time and responding to threats effectively. **Crawl:**Deploy an admissions controller with its default rule set. This will provide some degree of protection right out the gate and give you a chance to understand the tool. **Walk:**Add a cluster assessment component to scan existing workloads against the admissions controller rules without disrupting them. This helps identify non-compliant workloads, allowing manual remediation as needed. **Run:**Write your own rules, and do a dry run before enforcing. Adapt the existing ruleset of the admissions controller based on your specific security requirements and ensure you and your engineering teams understand the impact of admission control policies before enforcing them.
Though KSPM primarily focuses on cluster hardening rather than incident response, it still offers configurations to prevent, respond to and understand incidents historically. Real-time capabilities and flexible admission control are crucial for effective incident management.
**What Is Defense-in-Depth, and How Is It Implemented?**
Defense-in-depth, inspired by military strategy, involves creating layers of defense to impede attackers and make progress costly. In cybersecurity, the goal is to make adversaries work hard for each exploit, slowing them down to enhance detection and response. The strategies discussed here aim to hinder adversaries and empower defenders to respond effectively.
**Protect Your East-West Traffic**
While a Kubernetes cluster is a security boundary, it’s crucial to recognize it as an abstraction over hosts and network topologies. This expands the attack surface beyond workload interfaces and the Kubernetes API to include underlying hosts and networks, creating potential access points and opportunities for lateral movement. A service mesh can significantly reduce this surface by encrypting traffic, mutually authenticating services and limiting communication, thus enhancing security and visibility against lateral movement attempts in the cluster.
**Crawl:**The basic deployment of a service mesh will generally bring you encrypted East-West traffic and mutual authentication right out of the box. This isn’t *quite*as easy as hitting deploy: the services running on your cluster may need some tweaking to work well with the service mesh, but the mesh itself shouldn’t need any modification to bring you these benefits. **Walk:**Collect service mesh logs. The service mesh provides network log visibility for your cluster. This can be invaluable both in real-time detection and in investigating incidents. **Run** **:**Require apps to define/restrict network connections. A service mesh’s defense-in-depth benefit lies in its ability to restrict network connections on a per-app or per-service basis. This limits a compromised service to connecting only with specified services, reducing the impact and opportunities for lateral movement by attackers. It also enhances detection chances by creating error opportunities for attackers and generating noise in unauthorized access attempts. **Protect Key Configuration Files**
Kubernetes manages workloads by comparing a list of desired state API objects with the actual cluster state. It orchestrates systems like container runtimes and networking to align with this desired state. Protecting configuration files on the control plane and worker nodes is crucial to prevent attackers from escalating privileges or altering the cluster’s intended behavior. Restricting write access to these files to the root user is recommended for defense-in-depth.
**Crawl:**Manually harden critical files. You can literally do this by hand on each node, or you can use a configuration management system like Ansible to apply this hardening across your whole cluster. **Walk:**Use hardened node images. Move the process of hardening these files back a layer by baking the hardening of critical files into your image generation process. This ensures the files are hardened from the start when new nodes are deployed. **Run:**Set up monitoring for attempts to modify critical files. A clumsy attacker who attempts to modify these files should be easy to detect. A more clever attacker will notice the restricted permissions first and attempt an escalation to the root. Ideally, a host-based detection system (ie, an Endpoint Detection and Response system) will detect either.
**Conclusion**
Navigating the complexities of KSPM requires a strategic, layered approach that encompasses fundamental hardening techniques, enhanced incident response strategies and a comprehensive defense-in-depth framework.
[
YOUTUBE.COM/THENEWSTACK
Tech moves fast, don't miss an episode. Subscribe to our YouTube
channel to stream all our podcasts, interviews, demos, and more.
](https://youtube.com/thenewstack?sub_confirmation=1)