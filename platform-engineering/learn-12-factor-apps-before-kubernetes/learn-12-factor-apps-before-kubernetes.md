# 在 Kubernetes 之前学习 12 Factor 应用

翻译自 [Learn 12 Factor Apps Before Kubernetes](https://thenewstack.io/learn-12-factor-apps-before-kubernetes/) 。译者在团队里也一直把 12 factor 作为 Kubernetes 学习的必修前导课。译者和这个作者心有戚戚焉，确实很想告诉别人，这个很重要，但不好表达，而这个 12 factor 理论说出了我们很多的想法。不管使用何种管理工具，12 factor 都可以让云原生之旅更顺畅。

这些最佳实践为构建可扩展、可移植、可维护和有弹性的容器化应用程序提供了一个框架。

![](https://cdn.thenewstack.io/media/2023/04/6aff9eb5-shoes-14-1024x491.jpg)

您是否曾经在工作中使用容器化应用程序时苦苦挣扎，但又无法完全表达原因？

我最初接触容器的经历是在一家公司，他们以各种错误的方式实现了容器。例如，他们在容器内运行数据库，并没有使用外部卷进行存储。你没看错：他们将数据库存储写入 aufs 文件系统中，这不是为长期存储设计的，并且非常缓慢。当我提到这是一个可怕的想法，因为我们可能会失去所有数据时，答案是：“我们正在做快照备份，所以没问题。

他们放入容器中的第一个应用程序并没有好多少：

* 他们没有使用环境变量进行配置；相反，他们硬编码配置并挂载配置文件。
* 当数据库不可用时，应用程序立即死亡；它不会等待或重试，直到数据库变回可用。
* 有糟糕的日志消息或日志保存到文件，而不是[标准输出](https://12factor.net/logs)日志记录。
* 他们使用不同的应用程序运行[管理流程](https://12factor.net/admin-processes)，例如数据库迁移。
* 应用程序[不必要地](https://12factor.net/processes)是有状态的。

正如 [Kelsey Hightower 所提到的](https://medium.com/@kelseyhightower/12-fractured-apps-1080c73d481c)，我使用 entry-point 脚本解决了其中的大部分问题。但这是弥补糟糕设计的一个 hacky 解决方案。我记得我害羞地要求开发人员重新设计他们的应用程序以解决所有这些问题，只有我的意见支持我。所以我上网做了一些研究，发现了 12 Factor 应用 ，它不仅扩展和验证了我的观点，而且给了我一个很好的框架来支持我的论点。

## 为什么要学习 12 factor 应用

12-factor 应用方法是一组构建容器化应用程序的最佳实践。 Heroku 于 2011 年引入了这些实践，此后它们已被全球软件开发团队广泛采用。

这 12 个要素为构建可扩展、可移植、可维护和有弹性的应用程序提供了一个框架。但也许最重要的好处是它们创建的应用程序对操作员来说很容易，因为它们旨在与任何容器编排器无缝协作。

![](https://cdn.thenewstack.io/media/2023/04/537c6c54-image2.jpg)

Kubernetes (K8s) 最适合 12 factor 应用，因为它们是容器化应用程序的最佳设计实践。 K8s 作为容器编排器，其设计假设您的应用程序是 12 factor 的应用。

在不知道如何设计容器应用程序的情况下冒险进入容器编排将使操作它们的管理变得更加繁琐且可扩展性降低。当然，你可以让单体应用和设计糟糕的应用程序在 Kubernetes 中运行。例如，您可以挂载卷、运行 statefulSets 甚至进行垂直自动缩放。但最终，您将不得不应对高昂的运营成本：

| Factor                       | 未实施的运营成本                                                                                                                          |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Codebase                     | 具有共享代码库的应用程序更难更新和维护。                                                                                                                                            |
| Dependencies                 | 时间花在查找和安装应该明确定义并与容器一起打包的依赖项上。                                                                                                                                   |
| Config                       | 时间和工程花费在从源代码创建 entry-point 脚本和/或自定义镜像以更改硬编码配置。                                                                                                                            |
| Backing Services             | 更改支持服务时，迁移成本高且耗时，并且/或停机时间长。                                                                                                                                     |
| Build, release, run          | 将应用程序代码和运行的服务器视为一体会导致雪花服务器、痛苦的维护和昂贵的升级。                                                                                                                         |
| Processes                    | 共享状态时，应用程序无法水平扩展。升级时也不能无缝替换它们。                                                                                                                                  |
| Port binding                 | 这意味着要维护像 Tomcat 这样的 Web 服务器容器，从而导致显着的配置开销和膨胀的应用程序运行时间。                                                                                                          |
| Concurrency                  | 未在设计时考虑到并发性的应用程序可能会使用过多的资源，从而成为扩展的糟糕选择。                                                                                                                         |
| Disposability                | 这会导致数据丢失和性能问题，这是由于缺乏正常的关闭实现以及不处理请求以便它们可以处理崩溃。                                                                                                                   |
| Dev/prod parity              | 无法预测应用程序在生产中的表现。停机时间会增加并削弱部署速度。                                                                                                                                 |
| Logs                         | 将日志发送到日志仓库很繁琐。容器编排器期望日志使用标准输出。                                                                                                                                  |
| Admin Processes              | 时间被浪费在采购一个不属于应用程序一部分的流程上，甚至是手动完成。                                                                                                                               |

## 平台工程和 12 factor 应用

平台工程有助于通过内部开发人员平台 (IDP) 提供出色的自助服务和出色的开发人员体验。通过提供黄金路径和基于用户角色的多重抽象，IDP 显着降低了开发人员的认知负担。

在平台工程中，12 factor 应用很重要，因为开发人员使用 IDP 自助服务他们的应用程序和基础设施需求。内部开发人员平台通常利用容器编排并将服务的运营转移给开发人员，这意味着卓越的运营对于缓解上述所有问题至关重要。

像 Humanitec 这样的平台编排器位于 IDP 的中心，可以通过简单的工作负载规范轻松地将工作负载及其所有资源部署到所有环境。

Humanitec 使用 K8s 部署工作负载，因此，设计 12-factor 应用程序对于保持高运行性能至关重要。使用 IDP 时，开发人员可以自助满足其基础架构和配置需求，包括部署和操作应用程序。如果他们使用非 12 factor 应用程序，他们将遇到上述所有痛点。

例如，假设您有一个使用数据库的应用程序。假设您没有使用 12 factor 应用。在这种情况下，您可能需要将配置挂载到磁盘上，并且您用来自动执行此过程的任何工具都可能设计为将配置作为变量使用。如果你有多个环境，你会使问题复杂化。

总体而言，12 factor 应用使部署、管理和扩展应用程序变得更加容易。它们还使与其他开发人员的协作变得更加容易。

## 结论

12 factor 应用框架提供了构建可扩展、可移植、可维护和有弹性的容器化应用程序的最佳实践。在云中部署和运行应用程序时，它们对于保持卓越的运营至关重要。

平台工程帮助开发人员使用他们自己的基础设施并轻松操作他们自己的服务，但服务必须在设计时考虑到这些工具。我们鼓励所有开发人员采用 12 factor 方法，让他们的生活更轻松。

您的 12 Factor 应用程序准备好了吗？立即使用 Humanitec 对其进行标准化和部署。